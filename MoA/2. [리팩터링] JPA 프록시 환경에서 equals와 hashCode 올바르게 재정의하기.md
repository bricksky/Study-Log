
## "내 엔티티는 왜 조회되지 않을까?" JPA 프록시와 equals의 모든 것

> 🔗 **관련 PR**: [#refactor: JPA equals & hashCode 개선](https://github.com/team-memory-care/MoA-Backend/pull/151)

"분명 같은 ID를 가진 회원인데, `Set`에 넣으면 중복 제거가 안 됩니다."
"저장(`save`)하고 나니까 `contains`가 `false`를 반환해요."

JPA를 사용하는 백엔드 개발자라면 한 번쯤 겪어봤을 **객체 식별 문제**다. 처음에는 코드를 잘못 작성했나 싶어 밤을 새우지만, 원인을 파헤쳐 보면 그곳엔 **스프링의 핵심 기술인 프록시(Proxy)**와 **자바의 equals 규약** 사이의 미묘한 충돌이 숨어 있다.

이번 글에서는 **이펙티브 자바 Item 10**의 이론을 아주 상세하게 짚어보고, 이를 **JPA 환경**에서 안전하게 구현하는 방법을 정리한다.

### 리팩토링 요약

* **배경**: JPA 프록시 객체 비교 시 `getClass()` 불일치 및 영속화 전후 해시코드 변경 문제 발생
* **핵심**: `instanceof` 활용, Getter 접근, 상수형 HashCode 도입
* **결과**: 프록시 호환성 확보 및 컬렉션 내 데이터 정합성 보장

---

</br></br>

## 1. 스프링의 마법사, "프록시(Proxy)"

---

`equals`를 수정하기 전에, 문제의 원인이 되는 **프록시**가 도대체 무엇이며, 스프링은 왜 이 기술을 그토록 사랑하는지 이해해야 한다.

</br>

### 1.1 프록시 객체란?

프록시(Proxy)는 '대리인'이라는 뜻이다. 즉, **진짜 객체 대신 앞에 서 있는 가짜 객체(껍데기)**다. 클라이언트는 프록시를 진짜 객체인 줄 알고 호출하지만, 프록시는 그 요청을 받아 내부적으로 진짜 객체에게 일을 시키거나(위임), 필요한 시점에 진짜 객체를 로딩한다.

</br>

### 1.2 왜 사용하는가? (핵심 기능 2가지)

스프링과 JPA는 다음 두 가지 이유 때문에 우리 몰래 프록시를 끼워 넣는다.

**① 지연 로딩 (Lazy Loading): "필요할 때 가져온다"**

게시글(`Post`) 하나를 조회했다고 가정해보자. 이 게시글에는 작성자(`User`) 정보가 연관되어 있다. 만약 게시글을 볼 때 작성자 정보가 당장 필요 없다면? 굳이 DB에서 User 테이블까지 조인해서 가져올 필요가 없다.

* **동작**: 하이버네이트는 `User` 자리에 비어있는 **프록시 객체**를 넣어둔다.
* **초기화**: 실제 코드에서 `post.getUser().getName()`처럼 **실제 데이터를 사용하는 시점**에 DB 쿼리가 날아가고 진짜 객체가 채워진다. 이것이 성능 최적화의 핵심이다.

**② AOP & 트랜잭션: "몰래 로직을 감싼다"**

`@Transactional` 어노테이션을 붙이면, 메서드 시작 전에 트랜잭션을 열고(begin), 끝나면 커밋(commit)해야 한다. 하지만 우리가 작성한 코드에는 그런 로직이 없다.

* **동작**: 스프링은 **프록시 객체**를 만들어 우리가 만든 서비스 로직을 감싼다.
* **실행**: `프록시.메서드()` 실행 → 트랜잭션 시작 → `진짜객체.메서드()` 실행 → 트랜잭션 커밋. 개발자는 비즈니스 로직에만 집중할 수 있게 된다.

</br>

### 1.3 주의할 점

프록시 라이브러리(CGLIB 등)는 **리플렉션**을 사용해 가짜 객체를 만든다. 이때 객체를 생성하려면 **기본 생성자**가 필수다. 우리가 엔티티에 `@NoArgsConstructor(access = Protected)`를 습관처럼 붙이는 이유가 바로 여기에 있다.

</br></br>

## 2. Effective Java Item 10 "equals는 일반 규약을 지켜 재정의하라"

---

프록시의 정체를 알았으니, 이제 자바의 헌법이라 불리는 `Object` 명세의 **5가지 equals 규약**을 깊이 있게 살펴보자. 이 규약들은 수학적인 약속이라 하나라도 어기면 프로그램이 예측 불가능 상태에 빠진다.

**① 반사성 (Reflexivity)**

> **x.equals(x)는 항상 true여야 한다.**

가장 기본적인 성질이다. "나는 나다"라는 뜻이다. 만약 이걸 어기면, 컬렉션(`List`, `Set`)에 객체를 넣은 다음 `contains()`로 찾아도 `false`가 나온다.

**② 대칭성 (Symmetry)**

> **x.equals(y)가 true면 y.equals(x)도 true여야 한다.**

"나는 너와 같은데, 너는 나랑 다르다고?" 이러면 안 된다는 것이다. 보통 서로 다른 클래스끼리 비교하려다 사고가 난다.

* **실패 예시**: `MyString` 클래스를 만들어서 `String`과 비교되게 만들었다고 치자. `myString.equals("abc")`는 `true`가 나오게 짰지만, 정작 `"abc".equals(myString)`은 `false`가 나온다. `String` 클래스는 내가 만든 `MyString`의 존재를 모르기 때문이다.
* **해결**: 다른 클래스와는 아예 비교하지 않는 것이 상책이다.

**③ 추이성 (Transitivity)**

> **x=y이고 y=z이면, x=z여야 한다.**

가장 깨지기 쉬운 규약으로, **상속(Inheritance)** 관계에서 문제가 발생한다.

* **상황**: `Point(x,y)`를 상속받아 색상을 추가한 `ColorPoint(x,y,color)`가 있다.
* **딜레마**:
1. 색상을 무시하고 비교하면? -> `ColorPoint`끼리 색이 달라도 같다고 나와서 논리가 깨짐.
2. 색상을 따져서 비교하면? -> `Point`는 색이 없으니 `ColorPoint`와 다르다고 함(대칭성 위배).
3. 그렇다고 `getClass`로 막으면? -> 리스코프 치환 원칙(LSP) 위배.


* **결론**: 상속을 사용하면서 값을 추가하면, equals 규약을 완벽히 만족시킬 방법이 없다. 그냥 **상속 대신 필드로 포함(Composition)**시키는 게 답이다.

**④ 일관성 (Consistency)**

> **두 객체가 같다면, 수정되지 않는 한 영원히 같아야 한다.**

`equals`의 판단 기준에 **신뢰할 수 없는 자원**이 끼어들면 안 된다.

* **대표적 실수**: `java.net.URL` 클래스는 호스트 이름(도메인)을 IP 주소로 바꿔서 비교한다. 네트워크 상태에 따라 IP가 바뀌거나 연결이 안 되면 결과가 달라진다. 절대 따라 하면 안 된다.

**⑤ null-아님**

> **x.equals(null)은 항상 false여야 한다.**

`NullPointerException`을 던지라는 말이 아니다. `null`이 들어오면 조용히 `false`를 반환해야 한다. 코드에서 `instanceof`를 사용하면 입력이 `null`일 때 자동으로 `false`가 되므로 별도의 null 체크가 필요 없다.

</br></br>

## 3. 문제 상황: 프록시와 equals의 충돌

---

자, 이제 **[프록시의 특성]**과 **[equals 규약]**이 만났을 때 JPA 프로젝트에서 어떤 대참사가 일어나는지 확인해보자.

</br>

### 문제 1: getClass()와 프록시 타입 불일치

보통 IDE가 만들어주는 `equals`는 `getClass()`를 쓴다.

```java
if (o == null || getClass() != o.getClass()) return false;

```

* **JPA의 상황**: 원본 엔티티는 `User` 클래스지만, 프록시 엔티티는 `User$HibernateProxy...` 클래스다.
* **결과**: 클래스가 다르니 `false`가 반환된다.
* **해결**: **리스코프 치환 원칙**을 기억하자. 자식(프록시)도 부모(User)와 같은 타입으로 취급해줘야 한다. 따라서 `getClass()` 대신 **`instanceof`**를 써야 한다.

</br>

### 문제 2: 필드 직접 접근 (this.id vs other.id)

```java
if (this.id != other.id) return false;

```

* **JPA의 상황**: 프록시 객체는 진짜 데이터를 아직 안 가져왔다. 내부는 비어 있다.
* **결과**: `other`가 프록시라면 `other.id`는 `null`이다. 그래서 ID가 같아도 다르다고 판단한다.
* **해결**: 필드에 직접 손대지 말고, 반드시 **Getter(`getId()`)**를 호출해야 한다. 그래야 프록시가 "아, 데이터 필요하구나!" 하고 DB를 조회해서 값을 채워준다.

</br></br>

## 4. 핵심 이슈: 영속화 전후 해시코드 불일치

---

마지막으로 가장 찾기 힘든 버그인 **'해시코드 변경 이슈'**다.

1. **객체 생성**: `User u = new User("name");` -> ID는 `null`. 해시코드는 `0`이라고 치자.
2. **Set에 저장**: `set.add(u);` -> `0`번 방에 저장됨.
3. **DB 저장(Save)**: `repository.save(u);` -> **ID가 `100`으로 바뀜!**
4. **조회 시도**: `set.contains(u);`
* Set은 바뀐 ID(`100`)를 보고 "해시코드가 `100`이네? `100`번 방 가서 찾아봐야지"라고 생각한다.
* 하지만 객체는 아까 `0`번 방에 넣어뒀다.
* **결과**: 못 찾음 (`false`). 객체는 거기 있는데 없는 취급을 당한다.



</br></br>

## 5. 해결: JPA 환경에 최적화된 equals & hashCode

---

위의 모든 이론적 배경과 실무적 문제를 해결한 'JPA 엔티티 전용 표준 코드'다.

### 수정한 코드

```java
@Entity
public class User {
    
    @Id @GeneratedValue
    private Long id;

    // ... (필드 생략)

    @Override
    public boolean equals(Object o) {
        // 1. 반사성: 물리적으로 같은 메모리 주소면 무조건 true (성능 최적화)
        if (this == o) return true;
        
        // 2. 타입 확인: getClass() 대신 instanceof 사용
        // -> 프록시 객체(User의 자식)도 User 타입으로 인정해준다.
        if (!(o instanceof User user)) return false; 
        
        // 3. 식별자(ID) 비교
        // -> ID가 없다면(비영속 상태) 동등하지 않다고 본다.
        // 💡 중요: user.id 대신 user.getId() 사용!
        // -> 프록시 객체의 필드는 비어있으므로, Getter를 호출해 DB 값을 로딩해야 한다.
        return this.id != null && java.util.Objects.equals(this.id, user.getId());
    }

    @Override
    public int hashCode() {
        // 💡 중요: 변하지 않는 상수 반환 (getClass().hashCode())
        // ID 기반으로 해시를 만들면, 영속화(Save) 전후로 해시값이 변해 Set에서 조회가 불가능해짐.
        // 해시 충돌로 인한 성능 저하(O(N))를 감수하더라도, 데이터 정합성을 보장하는 것이 우선이다.
        return getClass().hashCode();
    }
}

```

### 리팩토링 포인트 요약

| 구분 | 기존 방식 (Bad) | 개선된 방식 (Good) | 이유 |
| --- | --- | --- | --- |
| **타입 비교** | `getClass()` | **`instanceof`** | 프록시 객체도 원본과 같은 타입으로 인식하기 위함 (LSP 준수) |
| **필드 접근** | `other.id` | **`other.getId()`** | 프록시 객체 내부의 필드는 `null`이므로 Getter로 초기화 유도 |
| **비교 대상** | 모든 필드 (`@Data`) | **`PK (id)`** | 엔티티는 식별자만 같으면 같은 객체임. 순환 참조 방지 |
| **HashCode** | `Objects.hash(id)` | **상수 반환** | 영속화 전후로 ID가 변경되어도 해시코드가 유지되어야 함 |

</br></br>

## 6. 결론

---

이번 리팩토링은 단순히 버그를 수정하는 것을 넘어, **자바의 기본 원칙(equals 규약)**과 **프레임워크의 동작 원리(JPA Proxy)**를 깊이 이해하는 계기가 되었다.

* 스프링의 **프록시**는 성능과 편의를 위해 필수적이지만, 객체 비교 시에는 까다로운 존재다.
* **이펙티브 자바 Item 10**의 규약은 단순 이론이 아니라 시스템의 안정성을 위한 필수 조건이다.
* 특히 JPA 엔티티에서는 **해시코드의 불변성**을 보장해야 영속화 전후에도 컬렉션을 안전하게 사용할 수 있다.

이제 프로젝트의 엔티티들은 지연 로딩 상황이나 컬렉션 내부에서도 안정적으로 식별될 수 있게 되었다.
