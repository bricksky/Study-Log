## "이미지가 왜 안 나오죠?" s3:// 대신 HTTPS를 입혀주는 동적 변환기 구축
> 🔗 **관련 PR**: [#refactor: S3 내부 URI의 HTTPS 동적 변환 로직 적용](https://github.com/team-memory-care/MoA-Backend/pull/60)


"분명 S3에 사진을 잘 올렸는데, 왜 클라이언트 화면에는 엑박만 뜰까?"
확인해 보니 DB에 `s3://...` 형태의 AWS 내부 URI가 저장되어 있었다. 처음에는 "DB를 https://...로 싹 업데이트해야겠다"고 생각했지만, 코드로 URL을 동적으로 변환하는 과정이 오히려 보안(도메인 위변조 방지)과 유지보수(인프라 변경 유연성) 측면에서 훨씬 우수한 아키텍처임을 깨닫게 된 과정을 정리한다.


### 리팩토링 요약

* **배경:** DB에 저장된 `s3://` 프로토콜을 브라우저가 인식하지 못해 이미지 출력 실패
* **핵심:** DB에는 '파일 식별자(Key)'만 남기고, DTO 변환 단계에서 `https://` 도메인을 동적으로 결합
* **결과:** 인프라 변경(S3 버킷 이동 등)에 유연하게 대응 가능하며, 데이터 정합성 강화

</br>

---

### 1. 문제 상황: "이미지가 안 떠요"

프로젝트(MoABackend) 개발 중 클라이언트 개발자로부터 문의가 왔다. S3에 이미지를 업로드했는데, 앱에서 이미지가 보이지 않는다는 것이다. DB를 까보니 `detail_data` JSON 컬럼에 이미지 경로가 이렇게 저장되어 있었다.

```json
{
  "imageOptionsUrl": [
    "s3://moa-bucket-s3/0208093d-1_시공간_7_2.png"
  ]
}

```

**문제 원인:** 브라우저나 앱은 `http://`나 `https://` 프로토콜만 해석할 수 있는데, AWS 내부에서 쓰는 `s3://` 프로토콜을 그대로 내려주고 있었던 것이다.

</br></br>

### 2. "그냥 DB를 다 바꿔버릴까?"

가장 먼저 든 생각은 "DB 마이그레이션"이었다. SQL의 `REPLACE` 함수를 써서 `s3://moa-bucket-s3/` 부분을 `https://s3.ap-northeast-2.../`로 일괄 치환하면 당장 문제는 해결된다. 하지만 "잠깐, 코드로 해결할 수 있지 않을까?" 라는 생각에 기존 DTO 변환 로직을 활용해보기로 했다.

**왜 DB에 URL을 박으면 안 될까?**

* **보안 취약 (Security):** 해커가 DB를 털어서 이미지 경로를 `https://hacker-site.com/malware.png`로 바꾸면, 클라이언트는 의심 없이 악성 사이트에 접속하게 된다.
* **인프라 종속 (Coupling):** 나중에 S3 버킷을 옮기거나 CloudFront(CDN)를 도입해서 도메인이 바뀌면, 수만 건의 DB 데이터를 다시 UPDATE 해야 한다.


</br></br>


### 3. DB는 '식별자'만, 코드가 '주소'를 만든다

우리는 "DB는 변하지 않는 파일의 Key(식별자)만 갖고 있고, 접속 주소(URL)는 코드가 환경에 맞춰 입혀준다"는 원칙을 세웠다.

</br>

#### Step 1. 도메인 상수화 (Constants.java)

S3 접속 도메인을 한곳에서 관리하도록 상수로 뺐다. 나중에 CDN을 붙이면 여기만 고치면 된다.

```java
// [KEY POINT] 인프라 주소는 코드에서 관리한다.
public class Constants {
    public static final String S3_URL_PREFIX = "https://moa-bucket-s3.s3.ap-northeast-2.amazonaws.com/";
}

```
</br>

#### Step 2. 업로드 시 '파일명'만 반환 (ImageServiceImpl.java)

이미지 업로드 직후, 전체 URL을 리턴하던 로직을 수정하여 순수 파일명(Key)만 리턴하게 했다. DB에는 깔끔한 파일명만 저장된다.

```java
private String uploadImageToS3(MultipartFile file) {
    // 1. UUID로 고유 파일명 생성
    String s3FileName = UUID.randomUUID().toString().substring(0, 10) + "_" + originalFileName;

    // ... (S3 업로드 로직) ...
    
    // 2. [변경] 전체 URL이 아닌 's3FileName'만 반환!
    // 기존: return s3Client.utilities().getUrl(...).toString();
    return s3FileName; 
}

```
</br>

#### Step 3. DTO: 레거시까지 품는 변환 로직 (QuizQuestionDto.java)

가장 중요한 부분이다. DB에 저장된 값이 ① 순수 파일명이든, ② 레거시 `s3://` URI든 상관없이 무조건 안전한 HTTPS URL로 변환해주는 어댑터 로직을 구현했다.

```java
public static SpacetimeQuizQuestionDto from(QuizQuestion entity, ObjectMapper objectMapper) {
    // ... JSON 파싱 ...
    List<String> rawOptions = ...; // DB에서 꺼낸 원본 리스트

    // [핵심] 스트림을 돌며 URL 변환 (Convert)
    List<String> fullUrlOptions = rawOptions.stream()
            .map(SpacetimeQuizQuestionDto::convertToHttpUrl)
            .toList();

    return new SpacetimeQuizQuestionDto(..., fullUrlOptions);
}

// [Helper Method] 모든 길은 HTTPS로 통한다
private static String convertToHttpUrl(String rawKey) {
    if (rawKey == null || rawKey.isBlank()) return "";

    // 1. 이미 http로 시작하면? -> 기존 데이터 호환 (Pass)
    if (rawKey.startsWith("http")) return rawKey;

    // 2. s3://... 형태라면? -> 파싱해서 파일명만 추출!
    if (rawKey.startsWith("s3://")) {
        int slashIndex = rawKey.indexOf("/", 5);
        if (slashIndex != -1) {
            rawKey = rawKey.substring(slashIndex + 1); // "bucket/" 뒤의 파일명 추출
        }
    }

    // 3. 최종 조립: 안전한 프리픽스 + 파일명
    // 해커가 이상한 주소를 넣어도 무조건 우리 버킷 주소가 강제로 붙는다.
    return Constants.S3_URL_PREFIX + rawKey;
}

```

</br></br>

### 4. 클라이언트 개발자와의 소통 (아키텍처 바로잡기)

이슈를 해결하는 과정에서 클라이언트 개발자가 "이미지 경로가 Redis에 저장되나요?"라고 묻는 해프닝이 있었다. 이 기회에 백엔드와 클라이언트가 이미지를 어떻게 주고받는지 아키텍처 흐름을 명확히 정리해주었다.

**[정정] 실제 아키텍처 흐름**

* **(X) 오해:** S3 - 레디스 - 서버 (URI) ...
* **(O) 정답:** S3(원본) - DB(RDS)(식별자 Key) - 서버(변환) - 클라(Full URL)

#### [상세 설명] 클라이언트 개발자가 알아야 할 2가지 흐름

클라이언트 동료에게 이렇게 말했다. "너는 내부 사정(DB에 뭐가 있는지) 몰라도 돼. 내가 줄 때는 무조건 https://로 줄게!"

</br>

**1. 이미지를 볼 때 (조회 Flow)**

* **DB (RDS):** 테이블에는 **파일의 키(식별자)**만 저장되어 있다. (값: `0208_시공간.png` 등)
* **Server (Backend):** DB에서 값을 꺼낸 뒤, DTO 변환 로직(`convertToHttpUrl`)을 실행한다. "어? 이건 키값이네? 앞에 도메인 붙이자!"
* **Client (App):** 서버로부터 완성된 전체 URL을 받는다. (값: `https://moa-bucket-s3.../0208_시공간.png`)
* **Browser/App:** 받은 URL로 이미지를 띄운다.
👉 **클라이언트 입장:** "서버한테 데이터 달라고 하면, 그냥 바로 쓸 수 있는 https 주소가 내려오는구나."

</br>

**2. 이미지를 올릴 때 (업로드 Flow)**

* **Client:** 사진 파일을 서버 API로 전송한다.
* **Server:** 받은 파일을 S3에 업로드하고, **파일명(Key)**만 생성한다.
* **Server → DB:** 생성된 파일명(Key)을 DB에 저장한다.
👉 **클라이언트 입장:** "사진 보내면 서버가 알아서 저장하고, 나중에 조회할 땐 URL로 주겠지."

</br>

#### [요약] 클라이언트 개발자에게 이렇게 말해주세요

> **백엔드 내부:** "DB에는 보안이랑 관리 때문에 파일 식별자(Key)나 내부 주소(s3://)로 저장하고 있어."
> **우리 사이의 약속:** "하지만 너한테 API 응답 줄 때는, 내가 코드로 다 변환해서 접속 가능한 **Full URL(https://)**로 내려줄 거야. 너는 아무 걱정 말고 그대로 `<img>` 태그에 넣으면 돼!"

#### 상황별 데이터 변화 (Request vs Response)

* **클라이언트의 요청:** `GET /api/v1/quiz/today`
* **백엔드의 동작:** DB에서 `s3://...` 조회 → DTO에서 `https://...`로 번역
* **클라이언트가 받는 응답:**

```json
{
  "questionId": 1,
  "imageOptionsUrl": [
    "https://moa-bucket-s3.s3.ap-northeast-2.amazonaws.com/0208_시공간.png"
  ]
}

```

</br></br>

### 5. 결론: "우연히 짠 코드가 정답이었다"

처음엔 `s3://` 데이터를 보고 "잘못 저장됐다"고 생각해서 DB를 고치려 했다. 하지만 기존 코드를 활용해 파싱 로직을 강화하는 쪽으로 방향을 틀었고, 결과적으로 더 튼튼한 아키텍처를 얻었다.

* **보안 강화:** 백엔드 코드가 URL 생성의 통제권(Control)을 쥔다. DB 변조 공격이 들어와도 엉뚱한 도메인으로 리다이렉트되지 않는다.
* **유지보수:** 내일 당장 AWS 리전을 옮겨도 DB 마이그레이션 없이 Constants 파일 한 줄만 수정하면 배포 끝이다.
