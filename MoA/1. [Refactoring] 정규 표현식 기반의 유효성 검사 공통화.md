## "김 유저"는 왜 가입될까? 정규 표현식을 활용한 입력 검증 강화
> 🔗 **관련 PR**: [#refactor: 유효성 검증 상수로 분리 및 적용](https://github.com/team-memory-care/MoA-Backend/pull/139)

"분명 `@NotBlank`를 붙였는데, 왜 이름 중간에 공백이 섞인 채로 가입이 될까?"
사용자로부터 이름을 입력받을 때 @NotBlank만으로는 '스페이스바'를 이용한 비정상적인 입력을 완벽히 막을 수 없다는 점을 발견했다.
처음에는 각 DTO마다 정규식을 직접 적으려 했으나, 서비스가 확장됨에 따라 검증 규칙이 파편화될 위험을 느꼈다. 
이에 ValidationConstants라는 전용 상수 클래스를 도입하여 검증의 원칙을 한곳에서 관리하고, 
공백조차 허용하지 않는 강력한 유효성 검사 아키텍처를 구축한 과정을 정리한다.


### 리팩토링 요약
- **배경**: `@NotBlank`의 중간 공백 허용 한계 발견 및 검증 로직 파편화 방지
- **핵심**: `ValidationConstants`를 통한 정규 표현식(Regex) 중앙 관리
- **결과**: 데이터 정합성 강화, 코드 재사용성 및 유지보수 효율성 증대

---


</br>


## 1. 문제 상황: "이름에 공백이 들어가서 가입돼요"

---

프로젝트(MoABackend) 개발 중, 사용자 이름 입력 필드에서 예기치 못한 입력 패턴이 확인되었다. 기존에는 `@NotBlank` 어노테이션을 사용하고 있었지만, 이는 "빈 문자열"이나 "공백으로만 된 문자열"은 막아주어도, `"김 유저"`와 같이 중간에 공백이 포함된 경우까지는 걸러내지 못했다.

**기존 코드의 한계:**

```java
@NotBlank(message = "이름은 필수 입력값입니다.")
String name; // "김 유저" -> 통과됨 (문제 발생)
```

사용자 데이터의 정합성을 위해 이름, 생년월일, 전화번호 등은 정해진 규격(포맷)을 엄격히 따라야 했고, 특히 '공백'은 데이터 처리 시 오류를 유발할 수 있는 잠재적 위험 요소였다.


</br>


## 2. "매번 DTO에 정규식을 복사해 넣을까?"

---

가장 쉬운 해결책은 각 DTO 필드 위에 `@Pattern(regexp = "...")`를 직접 적는 것이다. 
하지만 "잠깐, 회원가입 DTO가 5개로 늘어난다면?" 이라는 의문이 들었다.

**왜 정규식을 직접 박으면 안 될까?** 

- **유지보수 지옥:** 만약 이름의 최대 글자수를 10자에서 12자로 늘려야 한다면, 해당 정규식이 적힌 모든 DTO 파일을 찾아다니며 수정해야 한다. 하나라도 놓치면 시스템의 일관성이 깨진다.
- **가독성 저하:** 복잡한 정규식 문자열이 DTO 곳곳에 배치되면 코드가 지저분해 보이고 의도를 한눈에 파악하기 어렵다.


</br>



## 3. 검증 규칙의 '중앙화'

---

나는 검증의 기준과 메시지는 단 한 곳에서만 정의하고, DTO는 이를 참조만 한다는 원칙을 세웠다.


### Step 1. 유효성 상수 클래스 생성 (ValidationConstants.java)

모든 정규 표현식과 에러 메시지를 한곳으로 모았다. 클래스 인스턴스화를 막기 위해 `private` 생성자를 사용하여 안전성을 높였다.

```java
// main/java/com/example/moabackend/global/constant/ValidationConstants.java

public final class ValidationConstants {
    private ValidationConstants() {} 

    // 이름: 한글/영문만 2~10자 (공백 절대 불가)
    public static final String NAME_REGEX = "^[가-힣a-zA-Z]{2,10}$";
    public static final String NAME_MESSAGE = "이름은 공백 없이 한글 또는 영문 2~10자여야 합니다.";

    // 생년월일: 숫자 8자리
    public static final String BIRTHDATE_REGEX = "^\\d{8}$";
    public static final String BIRTHDATE_MESSAGE = "생년월일은 yyyyMMdd 형식의 8자리 숫자여야 합니다.";
    
    // ...전화번호, 인증코드 등 규칙 정의
}
```

### Step 2. DTO 적용: 상수를 활용한 선언적 검증

이제 DTO에서는 복잡한 정규식 대신 미리 정의된 상수를 호출하기만 하면 된다.

```java
// UserRegisterRequestDto.java 

public record UserRegisterRequestDto(
        @NotBlank(message = "이름은 필수 입력값입니다.")
        @Pattern(regexp = ValidationConstants.NAME_REGEX, message = ValidationConstants.NAME_MESSAGE)
        String name,

        @NotBlank(message = "생년월일은 필수 입력값입니다.")
        @Pattern(regexp = ValidationConstants.BIRTHDATE_REGEX, message = ValidationConstants.BIRTHDATE_MESSAGE)
        String birthDate,
        
        // ... 생략
) {}
```


</br>


## 4. 왜 이렇게 설계했는가? (Deep Dive)

---

### 4.1 왜 private 생성자를 썼나?

`ValidationConstants`는 `new`를 통해 객체를 만들 필요가 없는 클래스다. `private` 생성자를 선언함으로써 다른 개발자가 실수로 메모리를 낭비하는 것을 방지하고, "이 클래스는 값만 가져다 쓰는 도구함입니다"라는 의도를 명확히 전달했다.


### 4.2 정규식 `^[가-힣a-zA-Z]{2,10}$`의 위력

- `^`와 `$`: 문자열의 시작과 끝을 지정하여, 중간에 다른 문자가 섞이는 것을 원천 차단한다.
- 공백 미포함: 허용 문자에 공백( ``)을 넣지 않았기 때문에, 사용자가 스페이스바를 누르는 순간 검증 에러가 발생한다.


</br>

## 5. 결론: "데이터 정합성은 입구에서 결정된다"

---

처음에는 단순히 공백을 막으려 시작한 작업이었지만, 이를 통해 프로젝트 전반의 **검증 로직 관리 체계**를 바로잡을 수 있었다.

- **정확성:** `@NotBlank`가 놓친 '중간 공백'이나 '특수문자' 입력을 정규식으로 완벽히 차단했다.
- **생산성:** 새로운 DTO가 추가되어도 `ValidationConstants`에서 상수를 가져오기만 하면 되므로 개발 속도가 빨라졌다.
- **일관성:** 모든 가입/수정 로직에서 동일한 규칙을 적용함으로써 "어디서는 가입되고 어디서는 안 되는" 버그를 예방했다.

**교훈:** 작은 공백 하나를 막는 기술적인 해결책도 중요하지만, 그 해결책을 시스템 전체에서 **어떻게 우아하게 관리할지** 고민하는 것이 백엔드 개발자의 진정한 역할임을 다시금 깨달았다.
