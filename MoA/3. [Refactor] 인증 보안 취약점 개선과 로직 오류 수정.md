## "프리패스" 테스트 계정은 이제 안녕! 인증 보안 구멍 메우기

> 🔗 **관련 PR**: [#fix: 테스트 계정 검증 로직 수정, S3 퍼블릭 접근 차단, 인증코드 시도 횟수 제한 적용](https://github.com/team-memory-care/MoA-Backend/pull/154)

"편하자고 만든 테스트 계정이 보안 구멍이 될 줄이야."

앱 심사와 개발 편의를 위해 만들어둔 테스트 계정(010-XXXX-XXXX)이 비밀번호를 검사하지 않는다는 사실을 뒤늦게 발견했다. 
단순히 `if`문 하나로 분기만 해두고, 정작 내부에서 검증을 안 하고 있었던 것이다. 게다가 SMS 인증 로직을 살펴보니 무제한 시도가 가능했고, 실패 기록이 영원히 남는 논리적 오류도 숨어 있었다. 이번 글에서는 인증 시스템의 빈틈을 막고, 꼬여있던 Redis 로직을 바로잡아 안전한 로그인 프로세스를 구축한 과정을 정리한다.

### 리팩토링 요약

* **배경**: 테스트 계정의 로그인 검증 누락 및 SMS 인증의 무차별 대입 공격 취약점 발견
* **핵심**: 테스트 계정용 **방어 코드(Guard Clause)** 추가 및 Redis 만료 시간을 활용한 **실패 카운트 로직 개선**
* **결과**: 로그인 보안 강화, 영구 실패 기록 문제 해결, AWS 비용 절감

---

</br>

### 1. 문제 상황: "아무 번호나 넣어도 로그인이 된다고?"

로그인 로직을 점검하던 중 아찔한 코드를 발견했다. 테스트 계정 번호가 들어오면 별도의 로직을 타게 해 뒀는데, 정작 그 안이 **텅 비어 있었다.**

**기존 코드의 치명적 실수:**
누군가 테스트 계정의 전화번호만 알아낸다면, 비밀번호(인증코드) 칸에 아무 숫자나 넣어도 로그인이 성공하고 토큰이 발급되는 상황이었다.

**[Before: 취약한 코드]**

```java
// AuthServiceImpl.java
if (TEST_ACCOUNT_NUMBER.equals(resolvedNumber)) {
    // ⚠️ 텅 빈 블록: authCode에 "1234"를 넣든 "0000"을 넣든 다 통과됨
} else if (!verifyAuthCode(phoneNumber, authCode)) {
    throw new CustomException(UserErrorCode.INVALID_AUTH_CODE);
}

```

**[After: 안전한 코드]**

약속된 인증코드("0911")가 아니면 즉시 예외를 던지도록 **방어 코드**를 추가했다.

```java
// AuthServiceImpl.java
if (TEST_ACCOUNT_NUMBER.equals(resolvedNumber)) {
    // ✅ "0911"이 아니면 즉시 차단
    if (!"0911".equals(authCode)) {
        throw new CustomException(UserErrorCode.INVALID_AUTH_CODE);
    }
} else if (!verifyAuthCode(phoneNumber, authCode)) {
    // ... 일반 유저 검증 로직
}

```

</br></br>

### 2. SMS 인증의 논리적 오류: "왜 재전송했는데도 실패 횟수가 안 줄어들죠?"

SMS 인증 쪽을 파다 보니 더 복잡한 문제들이 얽혀 있었다.

1. 무작위 대입 공격: 4자리 숫자는 경우의 수가 10,000개에 불과히다. 공격자가 스크립트로 0000부터 9999까지 빠르게 요청을 보내면, 횟수 제한이 없어 100% 확률로 인증을 뚫을 수 있다.

2. 좀비 카운터: 실패 횟수를 제한하려 할 때, 실패 카운트 키(:fail)에 만료 시간을 설정하지 않으면 문제가 생긴다.인증코드는 5분 뒤 사라지지만, 실패 기록은 Redis에 영원히 남고,
사용자가 나중에 다시 인증을 시도할 때, 과거의 실패 횟수가 누적되어 있어 1번만 틀려도 바로 차단당하는 치명적인 문제가 발생한다.

3. 초기화 누락: 사용자가 "인증번호 재전송"을 눌러 새 코드를 받았음에도, 기존 실패 카운트를 초기화하지 않아 기회를 박탈하는 문제가 있다.


</br>

**[Before: 로직 누락]**

기존 코드에는 `delete`나 `expire` 설정이 없어서, Redis에 실패 카운트가 영원히 남아있었다.

**[After: 생명주기 관리 로직 추가]**

**Step 1. 재발급 시 실패 기록 초기화**
새 인증번호를 발급하는 시점에 과감하게 과거의 실패 기록을 삭제했다.

```java
// 인증번호 생성 메서드 (generate...AuthCode)
String failCountKey = AUTH_CODE_PREFIX + resolvedNumber + ":fail";

// ✅ 기존 실패 기록 초기화: 새 게임 시작!
stringRedisTemplate.delete(failCountKey); 

```

**Step 2. 검증 실패 시 만료 시간 동기화**
인증번호 유효시간이 5분이라면, 실패 기록도 5분 뒤엔 사라져야 한다. 틀릴 때마다 카운트를 올리면서 만료 시간도 같이 설정해 줬다.

```java
// verifyAuthCode 내부 (틀렸을 때)
Long count = stringRedisTemplate.opsForValue().increment(failCountKey);

// ✅ 좀비 카운터 방지: 실패 기록도 5분(CODE_TTL) 뒤 자동 삭제
stringRedisTemplate.expire(failCountKey, CODE_TTL_SECONDS, TimeUnit.SECONDS);

if (count != null && count >= 5) {
    // 5번 이상 틀리면 아예 인증코드 자체를 폐기 (보안 강화)
    stringRedisTemplate.delete(AUTH_CODE_PREFIX + resolvedNumber);
    throw new CustomException(UserErrorCode.AUTH_CODE_EXPIRED);
}

```

</br></br>

### 3. 내 지갑을 지켜라: S3 업로드 권한 제어
Constants.java의 NO_NEED_AUTH 리스트(Spring Security 필터 제외 목록)에 업로드 경로가 포함되어 있었다. 이로 인해 **로그인하지 않은 익명 사용자(해커, 봇)**도 API를 호출하여 무제한으로 파일을 업로드할 수 있는 상황니. 이는 AWS 과금 폭탄 공격이나, 악성 스크립트 파일 호스팅 용도로 악용될 수 있다.

**[Before: 위험한 설정]**

```java
public static List<String> NO_NEED_AUTH = List.of(
    "/api/v1/auth/login",
    "/api/v1/s3/upload" // ⚠️ 위험: 누구나 내 S3에 파일을 올릴 수 있음
);

```

**[After: 권한 제어 강화]**

목록에서 제거하여, 이제 `SecurityFilter`가 토큰 유무를 검사한다. 즉, 인증된 회원만 이미지를 업로드할 수 있다.

```java
public static List<String> NO_NEED_AUTH = List.of(
    "/api/v1/auth/login"
    // 🔒 삭제됨: 이제 토큰 없으면 접근 불가
);

```

</br></br>


### 4. 결론: 보안과 편의성 사이, 그리고 디테일

처음에는 개발할 때 편하려고 테스트 계정 검증을 대충 넘겼고, 기능 구현에 급급해 Redis 키의 수명 주기를 깊게 고민하지 않았다. 하지만 이런 작은 구멍들이 모여 서비스의 신뢰도를 떨어뜨리고 보안 사고를 부른다.

이번 리팩토링을 통해 "편의성이 보안을 침범해선 안 된다"는 원칙과, "데이터의 생성뿐만 아니라 소멸까지 책임지는 설계"가 얼마나 중요한지 다시 한번 확인했다. 
