# **Docker 가상화의 원리 (VM vs Container)**

## 1. OS 레벨 가상화: VM vs Docker

---

가상화의 핵심은 **"하나의 물리적 자원을 어떻게 쪼개서 쓸 것인가"**.

<img width="719" height="458" alt="image" src="https://github.com/user-attachments/assets/7b24592f-a77a-4aee-b2cb-8e6404027461" />


| **구분** | **하드웨어 가상화 (VM)** | **OS 레벨 가상화 (Container)** |
| --- | --- | --- |
| **핵심 도구** | **하이퍼바이저** (VirtualBox, VMware, KVM) | **컨테이너 엔진** (Docker, rkt, LXC) |
| **구조** | Host OS → 하이퍼바이저 → **Guest OS** | Host OS → 컨테이너 엔진 → **컨테이너** |
| **자원 공유** | 각 VM마다 독립된 커널(OS)을 가짐 | **호스트 OS의 커널을 공유** |
| **장점** | 논리적으로 완전히 분리되어 **보안성**이 높음 | 부팅이 없고 가벼워 **배포 속도**가 매우 빠름 |
| **단점** | OS 부팅이 필요해 무겁고 자원 점유율이 높음 | OS 종속성(리눅스에서 윈도우 컨테이너 불가 등) |

### **하드웨어 가상화란?**

- 구조: 하드웨어 위에 *하이퍼바이저*를 올리고 그 위에 독립된 게스트 OS를 통채로 설치하는 것.
- 특징: 각 가상 머신마다 커널, 바이너리, 라이브러리가 모두 포함된다. 윈도우 위에 리눅스 VM을 올리는 것
- 단점: OS 부팅 과정이 필요해서 무겁고, 메모리 점유율이 높다.

### **OS 레벨 가상화란?**

- 구조: 호스트 OS위에 컨테이너 엔진(Docker)을 실행하고, 호스트의 커널을 공유한다.
- 특징: 프로세스를 격리할 뿐, OS를 새로 띄우지 않는다.
- 장점: 부팅 과정 없이 프로세스만 실행하므로, 밀리초 단위로 시작되며 자원 소모가 매우 적다.
- 서버 1대에 VM은 10대만 띄울 수 있다면, 컨테이너는 100개도 띄울수 있기 때문에 인프라 비용을 획기적으로 줄일 수 있다.

### 하이퍼바이저 관련 추가 설명

[하이퍼바이저(Hypervisor, Hyper V)란?](https://www.redhat.com/ko/topics/virtualization/what-is-a-hypervisor)

<aside>

**하이퍼바이저란? 가상화를 가능하게 하는 핵심 기술**

하이퍼바이저는 프로세서, 메모리, 스토리지와 같은 컴퓨팅 리소스를 풀링하여[가상 머신(VM)](https://www.redhat.com/ko/topics/virtualization/what-is-a-virtual-machine)에 재할당하는 소프트웨어입니다. 이 기술을 통해 여러 VM을 생성하여 단일 물리 머신에서 실행하는 [가상화](https://www.redhat.com/ko/resources/15-reasons-adopt-openshift-virtualization-ebook)가 실현될 수 있습니다.

**하이퍼바이저의 작동 방식**

모든 하이퍼바이저에서 VM을 실행하려면 메모리 관리자, 프로세스 스케줄러, I/O(입력/출력) 스택, 기기 드라이버, 보안 관리자, 네트워크 스택 등의 운영 체제 수준의 구성 요소가 필요합니다.

하이퍼바이저는 각 VM에 할당된 리소스를 제공하고 물리적 리소스에 대한 VM 리소스의 스케줄링을 관리합니다. 예를 들어 하이퍼바이저가 스케줄을 관리하는 동안에도 물리적 하드웨어는 여전히 실행을 수행하므로 CPU는 VM의 요청에 따라 CPU 명령을 실행합니다.

다양한 운영 체제가 나란히 실행되고 [가상화](https://www.redhat.com/ko/resources/red-hat-openshift-virtualization-engine-datasheet)된 동일한 하드웨어 리소스를 하이퍼바이저와 공유할 수 있습니다. 이것이 [가상화의 주요 장점](https://www.redhat.com/ko/topics/virtualization)입니다. [가상화](https://www.redhat.com/ko/resources/simplify-your-virtual-machine-migration-overview)가 없으면 하드웨어에서 하나의 운영 체제만 실행할 수 있습니다.

기존 벤더와 오픈소스에서 제공하는 하이퍼바이저에는 다양한 옵션이 있습니다. VMware는 가상화 솔루션의 선도기업으로 ESXi 하이퍼바이저와 vSphere 가상화 플랫폼을 제공합니다.

</aside>

### VM과 컨테이너의 차이

<img width="1103" height="482" alt="image" src="https://github.com/user-attachments/assets/3080003e-d130-41b8-b6b7-04bc042de531" />

두 기술의 가장 큰 차이는 **운영체제(OS)의 공유 여부**에 있다.

| **구분** | **VM (가상머신)** | **컨테이너 (Container)** |
| --- | --- | --- |
| **핵심 도구** | **하이퍼바이저** (VirtualBox, VMware, KVM) | **컨테이너 엔진** (Docker, rkt, LXC) |
| **구조** | 하이퍼바이저 위에 독립된 **Guest OS**를 각각 실행 | Host OS → 컨테이너 엔진 → **컨테이너** |
| **속도** | 별도의 OS 부팅이 필요하여 상대적으로 느림 | OS 공유 구조로 인해 실행 및 동작 속도가 매우 빠름 |
| **호환성** | 윈도우 호스트에서도 리눅스 Guest OS 설치 가능 (OS 독립적) | 리눅스 OS에서 윈도우용 컨테이너 사용 불가 (OS 종속적) |
| **격리/보안** | 각 VM이 완전히 분리되어 보안상 더 안전함 | OS 커널을 공유하므로 보안 취약점 발생 시 다른 컨테이너에 영향 가능 |

## 2. 격리 기술의 핵심: Namespaces & Cgroups

---

컨테이너는 실페가 있는 가상머신이라기 보단, 특수한 제한이 걸린 프로세스의 개념에 더 가깝다.

그 제한을 거는 도구가 바로 위의 두가지이다.

### Namespaces - "보여주는 것의 격리"

Namespaces는 특정 프로세스가 시스템의 자원을 볼 때, “너는 이것만 봐!”라고 시야를 제한하는 기술이다.

컨테이너가 호스트나 다른 컨테이너를 보지 못하게 '가림막'을 치는 기술.

- **PID Namespace (Process ID): "번호표의 격리”**
    - 컨테이너라는 '독립된 방'을 하나 만들어주는 것이다.
    - 리눅스에서 PID 1번은 시스템을 관리하는 가장 중요한 **'주인(Init)'** 프로세스이다. 원래 호스트 OS에는 진짜 주인이 한 명뿐인데, PID 네임스페이스를 쓰면, 컨테이너 안의 프로세스도 "내가 이 방의 1번(주인)이야!"라고 생각하게 만드는 것
    - 컨테이너가 종료될 때 그 안의 모든 자식 프로세스를 깔끔하게 함께 종료시키기 위해서 PID를 만든다.
- **NET Namespace (Network): "네트워크 선의 격리”**
    - 컨테이너마다 전용 '가상 랜카드'와 '가상 IP'를 주는 것이다.
    - 원래 한 컴퓨터에서 8080 포트는 한 명만 쓸 수 있는데, 네임스페이스로 네트워크를 쪼개면, 컨테이너 A도 8080, 컨테이너 B도 8080을 가질 수 있게된다. 각자 다른 IP를 가진 '가상 컴퓨터'처럼 행동하기 때문에 가능하다.
- **MNT Namespace (Mount): "파일 창고의 격리”**
    - 프로세스에게 "이 폴더가 이 세상의 루트(/) 디렉토리의 전부야"라고 믿게 만드는 것이다.
    - 컨테이너는 호스트의 진짜 `/etc`, `/var` 폴더를 볼 수 없다. 대신 컨테이너 이미지에 담긴 가상의 파일 시스템만 보게 되는데, 이를 통해 보안을 강화할 수 있다.
- **기타 네임스페이스**
    - **UTS:** 컨테이너에게 호스트와는 다른 '이름(Hostname)'을 지어준다. 
    (예: 호스트 이름은 `DongHyun-PC`인데 컨테이너 이름은 `backend-server`로 설정 가능)
    - **IPC:** 프로세스끼리 대화할 때 쓰는 '공유 메모리'를 격리한다. 
    A 컨테이너 프로세스가 B 컨테이너 프로세스의 메모리를 훔쳐보지 못하게 막는다.
    - **USER:** 컨테이너 안에서는 **'루트(Root, 모든 권한)'** 인척 하지만, 실제 호스트 입장에서는 '권한 없는 일반 사용자'로 취급하게 만든다. 가장 중요한 보안 기술 중 하나

### Cgroups (Control Groups): "사용량의 제한"

네임스페이스가 '무엇을 보느냐'를 결정한다면, Cgroups는 **'얼마나 쓰느냐'**를 결정한다. 자원 낭비를 막는 방지턱 개념이다.

- **역할**: 특정 컨테이너가 호스트의 물리적 자원을 독점하여 다른 서비스나 호스트 OS를 멈추게 하는 '무법자'가 되지 않도록 방지한다. (무한 루프에 빠져 CPU를 100% 점유하거나 메모리를 다 써버려서 호스트 전체가 멈추는 것을 방지)
- **주요 제한 항목**:
    - **CPU**: 컨테이너가 사용할 수 있는 CPU 코어 수나 점유율을 제한한다.
    - **Memory**: 사용할 수 있는 최대 메모리 양을 정함. 이를 넘기면 커널이 프로세스를 강제 종료한다.
    - **Disk I/O**: 데이터를 읽고 쓰는 속도를 제한하여 특정 컨테이너가 디스크 성능을 독점하지 못하게 한다.

### 퀴즈

Q. 만약 컨테이너 안에서 `rm -rf /` (모든 파일 삭제) 명령어를 실행하면, 내 노트북(호스트 OS)의 파일도 다 지워질까요?

A. 아니오

---

**MNT Namespace의 보호막: "가상 루트 디렉토리"**

리눅스 커널의 MNT Namespace는 프로세스에게 "이 폴더가 이 세상의 시작(/)이야"라고 속인다.

- 실제 상황: 컨테이너의 파일들은 사실 내 노트북의 특정 구석진 폴더(예: `/var/lib/docker/overlay2/...`)에 저장되어 있는데,
- 컨테이너 안에서는 MNT Namespace 덕분에 컨테이너 안의 프로세스는 위와 같은 복잡한 경로를 보지 못합하고. 그저 자기가 가진 폴더를 전체 시스템의 루트(`/`)로 인식하게된다.
- 따라서, 컨테이너 안에서 `rm -rf /`를 치면, 컨테이너는 자기가 루트라고 믿는 '가짜 루트 폴더' 안의 내용만 열심히 지우게 되는 것. 호스트 OS 입장에서는 그저 특정 하위 폴더의 파일들이 지워지는 것뿐이라 내 노트북 전체 시스템에는 아무런 영향이 없다.

**예외: `privileged` 옵션 (만능 열쇠)**

하지만 도커를 실행할 때 `--privileged`라는 옵션을 주면 이야기가 완전히 달라진다. 이 옵션은 "이 컨테이너는 격리하지 말고 호스트와 똑같은 권한을 줘"라는 뜻.

- 이 옵션을 사용하면 커널이 쳐둔 네임스페이스 가림막이 거의 다 사라지고,
- 컨테이너가 호스트의 실제 하드 드라이브(`/dev/sda` 등)에 직접 접근할 수 있게 된다.
- 이 상태에서 해커가 호스트의 실제 디스크를 컨테이너 안에 연결(Mount)한 뒤 `rm -rf`를 실행하면, 진짜로 노트북 파일이 지워질 수 있다.

# 이미지 레이어 구조와 Union File System

## 1. Layer Stacking: "벽돌 쌓기”

---

도커 이미지는 하나의 거대한 파일이 아니라, 여러 개의 읽기 전용(Read-Only) 레이어가 겹겹이 쌓인 구조이다.

- **Dockerfile의 반영:** `FROM`, `RUN`, `COPY` 같은 명령어 하나하나가 실행될 때마다 새로운 레이어가 생성.
- **재사용성:** 만약 여러 개의 서비스를 만드는데 모두 `Ubuntu` 베이스 이미지를 사용한다면, 도커는 호스트 OS에 `Ubuntu` 레이어를 딱 하나만 저장하고 모든 컨테이너가 이를 공유하므로 용량을 획기적으로 줄어든다.

## 2. UnionFS (Union File System): "투명한 종이 겹치기”

---

여러 개의 레이어를 쌓았는데, 사용자에게는 어떻게 하나의 완성된 파일 시스템으로 보일까요? 그 마법이 바로 **UnionFS**이다.

- **UnionFS**는 여러 개의 디렉토리를 하나의 디렉토리처럼 합쳐서 보여준다. 위에서 아래로 내려다본다고 생각하면 되는데, 상단 레이어에 있는 파일이 하단 레이어에 있는 동일한 이름의 파일을 가리게 되어, 사용자는 최종적으로 합쳐진 모습만 보게 되는 것.
- **스토리지 드라이버:** 연구 자료에서 언급된 `overlay2`가 현재 도커에서 가장 널리 쓰이는 UnionFS 구현체라고 한다.

## 3. Copy-on-Write (CoW): "수정할 때만 복사하기

---

도커 이미지는 '읽기 전용'인데, 컨테이너 안에서 파일을 새로 만들거나 수정하면 어떻게 될까? 
이때 **Copy-on-Write** 전략이 사용된다.

1. 기존 이미지 레이어는 절대 수정되지 않는다.
2. 컨테이너가 실행되면 가장 위에 '읽기/쓰기(Read-Write) 레이어 (기록용 레이어)'가 하나 추가된다.
3.  만약 하단 레이어의 파일을 수정해야 한다면, 그 파일을 상단의 읽기/쓰기 레이어로 복사(Copy)해온 뒤 수정정하면, 원본은 그대로 보존되므로 안전하고 효율적으로 수정할 수 있다.

# 이미지 위생 (Image Hygiene)

---

이미지 위생이란 **컨테이너 이미지를 깨끗하고 안전하며 재현 가능하게 관리**하는 일련의 활동을 말한다. 연구 과제에서는 이를 위해 세 가지 핵심 규칙을 실적 지표로 관리하고 있다고 한다.

## 1. `latest` 태그 사용 금지

- 이미지의 버전을 명시할 때 항상 `v1.0.1`과 같이 **특정 버전**을 적어야 한다.
- `latest`는 "가장 최신"을 의미하지만, 시간이 지나면 가리키는 실제 이미지가 바뀐다. 이로 인해 어제는 잘 돌아가던 코드가 오늘 배포할 때 버전 차이로 에러가 나는 등의 문제가 발생할 수 있다.

## 2. `digest` 고정

- 태그 뒤에 `sha256:hash` 형태의 고유 식별값(Digest)을 붙여서 사용한다.
- 태그(예: `v1.0`)는 누군가 악의적으로 동일한 이름으로 바꿔치기할 수 있지만, Digest는 이미지 내용이 1비트라도 바뀌면 완전히 달라진다. 따라서 Digest를 고정하면 중간에 이미지가 변조되는 것을 원천 차단하여 무결성을 보장할 수 있다.

## 3. 이미지 최소화 및 공격 표면 축소

- 이미지 안에 `curl`, `telnet`, `git` 등 서비스 실행에 꼭 필요하지 않은 패키지를 모두 제거한다.
- 해커가 컨테이너에 침투했을 때, 내부에 도구들이 많으면 이를 이용해 2차 공격을 시도하기 쉬워진다. 이를 공격 표면이라고 하며, 이미지 크기를 작게 유지할수록 해커가 쓸 수 있는 도구가 사라져 보안성이 비약적으로 높아지게된다.

## 4. 퀴즈

Q. Dockerfile에서 `RUN apt-get update && apt-get install -y vim` 처럼 두 명령어를 `&&`로 묶어서 한 줄에 쓰는 이유가 무엇일까요?

A: 레이어의 개수를 줄이기 위해서이다! 명령어를 각각 다른 줄에 쓰면 레이어가 2개 생기지만, `&&`로 묶으면 1개의 레이어만 생성되어 전체 이미지 크기를 더 작고 효율적으로 관리할 수 있다. 이것이 바로 이미지 최적화의 시작.

---

**1. 레이어 생성 방식의 차이: "불필요한 중간 단계 삭제"**

도커 파일의 명령어(`RUN`, `COPY`, `ADD`)는 실행될 때마다 새로운 Read-Only 레이어를 만든다.

- 따로 썼을 때 (2개 레이어):
    1. `RUN apt-get update`: 업데이트된 패키지 리스트 정보가 담긴 레이어 생성.
    2. `RUN apt-get install -y vim`: 설치된 `vim` 파일이 담긴 레이어 생성.
- 합쳐 썼을 때 (1개 레이어):
    - `RUN apt-get update && apt-get install -y vim`: 업데이트와 설치가 완료된 최종 상태만 하나의 레이어에 저장된다.

**2. 저장 공간의 마법: "지웠지만 지워지지 않는 파일"**

이 부분이 가장 중요합니다. 도커의 Copy-on-Write(CoW) 특성 때문에 발생하는 현상이다.

- 패키지를 설치하면 임시 설치 파일들이 `/var/lib/apt/lists/` 같은 곳에 남는데,
- 잘못된 예시
    
    ```markdown
    RUN apt-get update && apt-get install -y vim
    RUN rm -rf /var/lib/apt/lists/* # 별도의 줄에서 삭제
    ```
    
    이 경우, 아래 레이어에서 파일을 지워도 이전 레이어에 이미 파일이 기록되어 있기 때문에 전체 이미지 크기는 줄어들지 않는다. (상단 레이어에서 '안 보이게'만 가려둔 상태)
    
- 위생적인 예시 (이미지 최소화)
    
    ```markdown
    RUN apt-get update && apt-get install -y vim && \
        rm -rf /var/lib/apt/lists/*
    ```
    
    한 줄에서 설치와 삭제를 동시에 하면, 임시 파일이 아예 기록되지 않은 깨끗한 레이어가 생성된다. 이것이 연구 자료에서 강조하는 '이미지 최소화'의 핵심 기술!!
    

**3. 캐싱(Caching) 문제 해결: "최신 상태 보장"**

도커는 빌드 속도를 높이기 위해 각 레이어를 캐싱한다.

- 만약 `RUN apt-get update`를 별도의 레이어로 분리해 두면, 나중에 다른 패키지를 추가하고 싶어 `RUN apt-get install -y curl`을 추가했을 때 도커는 "update 레이어는 예전에 만든 게 있네?" 하고 옛날 업데이트 정보(캐시)를 그대로 사용해 버립니다.
- 결과적으로 최신 버전의 패키지를 받지 못하거나 설치 에러가 발생할 수 있다. `&&`로 묶어두면 `update`와 `install`이 항상 세트로 실행되므로 이런 **캐시 오염** 문제를 방지할 수 있다.
