## 1. 연구의 시작: 배달 앱을 보며 든 궁금증

---

최근에 배달 앱으로 치킨을 시켰는데, 지도 위에서 라이더님의 아이콘이 실시간으로 움직이는 걸 봤다. 문득 "수십만 명의 라이더가 동시에 움직일 텐데, 서버는 이 많은 위치를 어떻게 실시간으로 다 알고 있을까?" 하는 궁금증이 생겼다.

보통 웹 개발을 배울 때 데이터는 데이터베이스에 저장한다고 배웠다. 그럼 라이더의 위도와 경도 좌표도 DB에 계속 업데이트하고 있을 텐데, 기존의 방식대로 하면 어떤 문제가 생길까? 이 질문에 답하기 위해 가장 대중적인 데이터베이스인 PostgreSQL과 그 확장 기능인 PostGIS를 공부하며 이번 연구를 시작한다.

</br>

### 1.1 RDBMS

<img width="1152" height="366" alt="image" src="https://github.com/user-attachments/assets/2b44f18d-af93-49fd-8442-4459564a86d5" />

우리가 흔히 '엑셀 표'처럼 데이터를 관리한다고 말할 때의 주인공이다. 1970년대에 정립된 모델이지만, 여전히 데이터베이스의 표준으로 불린다.

- **구조적 특징:** 
데이터를 행과 열로 구성된 테이블에 저장한다. '사용자' 테이블과 '주문' 테이블이 있다면, 두 테이블 사이의 관계(Relation)를 정의해 효율적으로 데이터를 관리한다.
- **강점 (안전성):** 
데이터가 중복되지 않게 관리(정규화)하고, 한 번 저장된 데이터는 정전이 나도 사라지지 않도록 보장한다. 즉, "신뢰가 생명인 데이터"를 다룰 때 최적의 도구다.

</br>

### 1.2 PostgreSQL

수많은 RDBMS 중 왜 많은 기업이 PostgreSQL을 선택할까? 공부를 해보니 단순히 데이터를 저장하는 기능을 넘어 '확장성'이 압도적이라는 점을 알게 되었다.

- **차별점:** 다른 DB들은 정해진 데이터 타입(숫자, 문자열 등)만 다룰 수 있는 경우가 많지만, PostgreSQL은 사용자가 원한다면 새로운 데이터 타입을 직접 정의해서 추가할 수 있다. 이러한 유연성 덕분에 '지도 데이터 전용 엔진'인 PostGIS가 그 위에서 탄생할 수 있었다.

</br>

### 1.3 PostGIS

PostgreSQL을 강력한 '지리정보 시스템'으로 변신시켜 주는 핵심 모듈이다.

- **왜 필요한가?:** 
일반 DB에 위도 `37.5`와 경도 `126.9`를 숫자로 저장하면, DB는 이를 단순한 숫자로만 인식한다. 두 지점 사이의 거리를 계산하려면 사람이 직접 복잡한 삼각함수 공식을 SQL로 짜야 한다.
- **핵심 기능:**
    - Geometry/Geography 타입: 좌표를 점, 선, 면이라는 '도형'으로 인식하고 저장한다.
    - 공간 연산 함수: `ST_Distance(A, B)`라는 함수 한 줄이면 곡률까지 계산해서 두 지점 사이의 정확한 거리를 알려준다.
    - 공간 인덱스: 수천만 개의 좌표 중에서 "지금 내 주변 1km 안에 있는 것만 찾아줘"라는 요청을 빛의 속도로 처리해 주는 특수한 목차 기능을 제공한다.


</br></br></br>



## 2. "라이더님 어디세요?" - 폴링의 비효율성

---

라이더의 위치를 앱에 띄우려면, 앱(클라이언트)이 서버에 위치를 물어봐야 한다. 가장 단순한 방법은 폴링이다. 이 방식은 클라이언트가 주도권을 가지고 서버에 상태를 확인하는 구조를 가진다.

앱이 1초나 3초마다 "라이더님 지금 어디쯤인가요?"라고 서버에 계속 쿼리(질의)를 날리는 것이다. 그런데 공부를 해보니 이 방식에는 '빈 쿼리'라는 치명적인 문제가 있었다.

만약 라이더님이 신호 대기 중이라 1분 동안 멈춰 있다면? 내 앱은 아무 변화가 없는데도 1초마다 의미 없는 질문을 던지고, DB는 매번 "아직 거기야"라고 대답하며 자원을 낭비한다. 사용자가 많아질수록 서버가 감당해야 할 질문 횟수는 걷잡을 수 없이 늘어나고, 서버는 결국 뻗어버릴 것이다.

- **폴링:** 클라이언트가 정해진 주기마다 서버에게 "새로운 정보 있어?"라고 계속 묻는 방식. 구현은 쉽지만, 정보가 없을 때도 리소스를 쓴다는 단점이 있다.
- **빈 쿼리:** 폴링을 했을 때 돌아올 새로운 정보가 없는데도 실행되는 불필요한 조회 작업. CPU와 메모리를 낭비하게 만든다.
- **쿼리:** 데이터베이스에게 "이 데이터를 찾아줘" 혹은 "이걸 저장해줘"라고 보내는 명령문.

</br>

### 2.1 폴링의 동작 원리와 부하의 전이

폴링은 정해진 시간 간격(Interval, 예: 1초 혹은 3초)마다 클라이언트가 서버에 `HTTP Request`를 보내고, 서버는 그 시점의 데이터베이스 상태를 조회하여 응답하는 과정을 반복한다.

1. Request 단계: 클라이언트가 `GET /api/v1/rider/location`과 같은 요청을 전송한다.
2. Processing 단계: 서버는 이 요청을 받아 데이터베이스에 쿼리를 실행한다. 
(예: `SELECT lat, lon FROM rider_locations WHERE id = 123;`)
3. Response 단계: 조회된 좌표를 JSON 형태로 클라이언트에 반환한다.

이 과정이 수천, 수만 명의 사용자에게 동시에 일어날 때 시스템의 부하는 선형적으로 증가한다. 사용자 수를 N, 폴링 주기를 T라고 할 때, 초당 발생하는 쿼리 수는 N/T가 된다. 즉, 사용자가 10만 명이고 주기가 1초라면 DB는 초당 10만 건의 단순 조회 쿼리를 견뎌야 한다.

</br>

### 2.2 '빈 쿼리'가 시스템에 주는 타격

연구 과정에서 가장 주목해야 할 성능 저하 요인은 빈 쿼리 문제다. 실시간 위치 서비스에서 라이더가 신호 대기 중이거나 교통 체증으로 인해 정지해 있는 상황을 가정해 보자.

- 상태 유지: 라이더의 좌표 데이터는 DB 내에서 변하지 않았다.
- 불필요한 연산: 하지만 클라이언트는 이 사실을 모르기 때문에 정해진 주기마다 계속 조회를 요청한다.
- 리소스 낭비: DB 엔진은 쿼리를 실행하기 위해 SQL 파싱, 실행 계획 생성, 인덱스 페이지 접근, MVCC 스냅샷 생성 등의 복잡한 내부 과정을 매번 수행한다.

결과적으로 데이터에 아무런 변화가 없음에도 불구하고 DB의 CPU 자원과 메모리 대역폭이 소모되며, 이는 정작 중요한 데이터 수정(`UPDATE`)이나 결제 트랜잭션을 처리해야 할 자원을 뺏어오는 결과를 초래한다.

</br>

### 2.3 왜 폴링은 대규모 서비스에서 실패하는가?

단순히 "쿼리가 많아서"를 넘어, 시스템 하부 구조에서 발생하는 병목은 다음과 같다.

1. 커넥션 풀 고갈: 각 폴링 요청은 DB 커넥션을 점유한다. 요청이 너무 잦아지면 가용한 커넥션이 모두 소모되어 새로운 요청이 대기 상태에 빠지는 '병목 현상'이 발생한다.
2. 컨텍스트 스위칭 오버헤드: 수만 개의 요청을 처리하기 위해 서버 OS 수준에서 수많은 스레드 간의 전환이 일어나며, 이 과정에서 발생하는 CPU 비용이 실제 비즈니스 로직 처리 비용보다 커질 수 있다.
3. HTTP 오버헤드: 단순한 좌표 값 몇 바이트를 받기 위해 매번 HTTP 헤더와 TCP 핸드쉐이크 과정을 거치는 것은 네트워크 자원 측면에서 매우 비효율적이다.

</br>
</br>
</br>

## 3. “왜 위치 업데이트가 느려질까?" - ACID와 MVCC

---

DB에 위치를 저장할 때, 왜 고속 처리가 힘든지 내부 구조를 찾아봤다. 그 이유는 RDBMS의 기본 원칙인 ACID 때문이었다.

은행 계좌 이체처럼 데이터가 1원도 틀리면 안 되는 상황에서는 ACID가 필수다. 하지만 위치 정보는 1초만 지나도 과거 데이터가 되는 휘발성 정보다. RDBMS는 이 좌표 하나를 바꿀 때도 "정말 안전하게 저장됐는지"를 너무 꼼꼼하게 따진다.

특히 PostgreSQL의 MVCC라는 방식이 눈길을 끌었다. 데이터를 수정할 때 기존 좌표를 지우고 새로 쓰는 게 아니라, 기존 데이터는 옆으로 치워두고 새 버전을 하나 더 만든다. 초당 수만 번 좌표를 바꾸면 DB 안에는 '치워둔 쓰레기 데이터'가 산더미처럼 쌓이고, 이걸 치우느라 성능이 뚝 떨어진다.

- **ACID (원자성, 일관성, 고립성, 지속성):** 
데이터베이스가 데이터를 안전하게 처리하기 위해 지켜야 하는 4가지 철칙이다. 하나라도 실패하면 전체를 취소하는 등 매우 엄격하다.
- **MVCC (다중 버전 동시성 제어):** 
데이터에 접근할 때 여러 버전을 만들어 관리하는 방식. "내가 수정하는 동안 남이 읽을 수 있게" 해주지만, 수정이 너무 잦으면 쓰레기 데이터가 많이 생긴다.
- **Vacuum:** 
MVCC 방식에서 생긴 쓰레기 데이터들을 정리해서 용량을 확보하는 작업. 이 작업이 돌아갈 때 DB 성능이 저하되기도 한다.

</br>

### 3.1 ACID 트랜잭션 보장을 위한 오버헤드

데이터베이스에 좌표를 하나 업데이트할 때마다 RDBMS 내부에서는 ACID 원칙을 지키기 위한 복잡한 연산이 수행된다.

- **원자성(A)과 지속성(D)의 대가 - WAL(Write-Ahead Logging):** 
데이터가 손실되지 않도록 DB는 실제 데이터 파일을 수정하기 전, 변경 내용을 로그 파일에 순차적으로 먼저 기록해야 한다. 초당 수만 건의 업데이트가 발생하면 디스크에 로그를 쓰는 I/O 부하가 급증하게 된다.
- **고립성(I)과 일관성(C)의 대가 - Locking:** 
여러 사용자가 동시에 같은 데이터를 수정하거나 조회할 때 데이터가 꼬이지 않도록 데이터베이스는 특정 영역에 '잠금'을 건다. 이는 동시 처리 성능을 제한하는 직접적인 원인이 된다.

결과적으로, 1초 뒤면 가치가 사라지는 휘발성 데이터인 '위치 좌표'를 처리하기 위해 DB 엔진은 금융권 수준의 엄격한 안전 장치를 매번 가동하는 셈이며, 이는 시스템 자원의 낭비로 이어진다.

</br>

### 3.2 MVCC와 쓰기 증폭 현상

PostgreSQL을 포함한 많은 RDBMS는 동시성 제어를 위해 MVCC를 채택하고 있다. 이는 데이터를 수정할 때 기존 데이터를 직접 덮어쓰지 않는 방식이다.

1. **Non-In-Place Update:** 위치 데이터가 업데이트되면 DB는 기존의 행을 '삭제 예정' 상태로 표시하고, 새로운 좌표가 담긴 행을 추가로 생성한다.
2. **데이터 팽창:** 좌표가 1초마다 바뀌면 1분만 지나도 한 명의 라이더당 60개의 '쓰레기 데이터'가 쌓이게 된다.
3. **인덱스 부하:** 데이터 행이 새로 생성될 때마다 해당 행을 가리키는 인덱스 정보도 매번 갱신되어야 하므로, 실제 데이터 변경량보다 훨씬 많은 양의 디스크 쓰기가 발생하는 쓰기 증폭 현상이 발생한다.

</br>

### 3.3 Vacuum 프로세스와 시스템 지연

MVCC로 인해 발생한 'Dead Tuple'은 저장 공간을 계속 점유하므로, 이를 정리하여 재사용 가능한 상태로 만드는 Vacuum 과정이 필수적이다.

- **자원 경합:** PostgreSQL은 보통 `autovacuum`이 백그라운드에서 동작하며 쓰레기를 청소한다. 하지만 고빈도 업데이트 상황에서는 청소해야 할 쓰레기가 쌓이는 속도가 청소 속도보다 빨라지게 된다.
- **성능 스파이크:** Vacuum이 대량의 쓰레기 데이터를 처리하기 위해 동작하는 동안 디스크 I/O와 CPU 점유율이 급격히 상승하며, 이로 인해 실제 서비스 쿼리의 응답 속도가 갑자기 느려지는 '지연 시간 스파이크' 현상이 빈번하게 발생한다.

</br>
</br>
</br>

## 4.  강남역에서 앱이 먹통이 되는 이유 - 락 경합

---

라이더가 강남역 같은 특정 지역에 몰리면 왜 더 느려질까? 이건 공간 인덱스와 락(Lock) 개념으로 설명할 수 있었다. 

PostGIS는 지도 데이터를 빠르게 찾으려고 지도를 사각형 칸으로 나누어 관리한다. 이걸 공간 인덱스라고 부른다. 그런데 수백 명의 라이더가 강남역이라는 같은 사각형 칸 안에서 동시에 자기 위치를 업데이트하려고 하면 문제가 터진다.

DB는 데이터가 꼬이지 않게 하려고 한 번에 한 명씩만 수정할 수 있게 잠금을 건다. 한 명이 수정하는 동안 나머지는 줄을 서서 기다려야 한다. 이걸 락 경합이라고 하는데, 이 병목 현상 때문에 실시간성이 무너지는 것이다.

- **인덱스:** 책의 맨 뒤에 있는 '찾아보기'처럼, 데이터를 빨리 찾기 위해 미리 정리해둔 목차다. 공간 인덱스는 지도상의 좌표를 빨리 찾기 위한 목차다.
- **락:** 데이터를 수정할 때 다른 사람이 건드리지 못하게 잠그는 장치.
- **락 경합:** 여러 명이 동시에 같은 데이터를 수정하려고 줄을 서서 대기하며 시간이 지체되는 현상.
- **쓰기 증폭:** 실제 데이터 1개를 바꿨는데, 로그를 남기고 인덱스를 고치느라 실제로는 더 많은 양의 쓰기 작업이 디스크에서 일어나는 현상.

</br>

### 4.1 PostGIS의 공간 인덱스: GiST와 R-Tree 구조

PostGIS는 수백만 개의 좌표 중 필요한 데이터를 빠르게 찾기 위해 공간 인덱스를 사용한다. 일반적으로 PostgreSQL에서는 GiST라는 틀 위에 R-Tree 알고리즘을 구현하여 사용한다.

- **동작 원리:** 지도를 수많은 작은 사각형으로 쪼개고, 이 사각형들을 계층적인 트리 구조로 관리한다. 쿼리가 들어오면 전체 데이터를 뒤지는 대신, 해당 좌표가 포함된 사각형 가지만 타고 내려가기 때문에 검색 속도가 비약적으로 빠르다.
- **업데이트의 함정:** 문제는 검색이 아니라 수정(`UPDATE`)에서 발생한다. 라이더가 이동하여 좌표가 바뀌면, R-Tree 인덱스 내에서 해당 좌표가 속한 사각형의 경계선을 다시 계산하거나, 필요하다면 노드를 분할하여 트리의 균형을 맞춰야 한다.

</br>

### 4.2 락 경합: 줄을 서야 하는 트랜잭션들

데이터베이스는 여러 사용자가 동시에 같은 데이터를 수정할 때 데이터가 깨지지 않도록 락 ****메커니즘을 사용한다. 이 락이 '병목의 주범'이 된다.

1. **인덱스 페이지 잠금:** 라이더 A가 위치를 업데이트하면, 그가 속한 공간 인덱스의 특정 노드(페이지)에 배타적 잠금(Exclusive Lock)이 걸린다.
2. **대기열 발생:** 이때 같은 구역에 있는 라이더 B, C, D가 동시에 위치를 업데이트하려고 하면, A의 작업이 끝날 때까지 CPU는 연산을 멈추고 대기해야 한다.
3. **순차 처리화:** 실시간 시스템은 병렬 처리가 핵심이지만, 락 경합이 심해지면 모든 작업이 한 줄로 서서 처리되는 직렬화 현상이 발생한다. 결국 초당 10,000건을 처리할 수 있는 서버라도, 특정 구역의 락 때문에 초당 100건도 처리하지 못하는 상태가 된다.

</br>

### 4.3 쓰기 증폭과 디스크 I/O의 한계

위치 정보 하나를 바꿀 때 발생하는 비용은 생각보다 막대하다. 이를 쓰기 증폭 현상이라 한다.

- **현상:** 사용자는 단순한 숫자(위도, 경도) 2개를 바꿨을 뿐이지만, DB 내부에서는 1) 변경 로그(WAL) 기록, 2) 데이터 페이지 수정, 3) 공간 인덱스 트리 재구성이라는 세 가지 작업이 동시에 일어난다.
- **결과:** 특히 공간 인덱스 갱신은 일반 텍스트 인덱스보다 연산량이 훨씬 많아 디스크 I/O 대역폭을 순식간에 점유한다. 핫스팟 지역에서는 이 I/O 부하가 락 대기 시간과 맞물려 시스템 전체의 지연 시간을 폭발적으로 증가시킨다.

</br>
</br>
</br>

## 5. 결론: "기존 방식으로는 한계가 명확하다"

오늘의 공부를 통해 내린 결론은 이렇다. RDBMS와 PostGIS는 데이터를 '안전하게' 보관하는 데는 최고지만, 
미친 듯이 쏟아지는 실시간 좌표를 처리하기에는 너무 무겁고 느리다.

</br>

### 5.1 연구 요약: 핵심 병목 요인

- **폴링의 비효율성:** 클라이언트가 주기적으로 데이터를 요청하는 구조는 데이터의 변화가 없는 상황에서도 서버와 DB의 자원(CPU, Connection Pool)을 지속적으로 점유한다. 이는 사용자 수가 늘어날수록 시스템 전체를 지치게 만드는 핵심 원인이 된다.
- **ACID와 휘발성 데이터의 부조화:** RDBMS는 1초 뒤면 과거가 되는 위치 좌표를 저장할 때도 엄격한 ACID 원칙을 고수한다. 특히 MVCC 방식의 업데이트는 물리적인 쓰기 증폭을 유발하여 디스크 I/O에 막대한 부하를 주며, 주기적인 Vacuum 작업으로 인한 성능 스파이크를 발생시킨다.
- **공간 인덱스의 락 경합:** 특정 지역(핫스팟)에 사용자가 밀집할 경우, 해당 구역을 담당하는 공간 인덱스(GiST/R-Tree) 페이지에 대한 수정 권한을 얻기 위해 트랜잭션들이 줄을 서게 된다. 이 과정에서 병렬 처리가 불가능해지는 직렬화 현상이 발생하여 실시간성이 완전히 무너진다.

</br>

### 5.2 대안적 아키텍처의 필요성

이러한 한계를 극복하기 위해서는 데이터베이스가 중심이 되어 모든 조회와 수정을 처리하는 기존의 '데이터 중심’ 구조에서 벗어나야 한다는 결론에 도달했다.

- **이벤트 기반(Event-Driven) 방식으로의 전환:** 클라이언트가 매번 묻는 것이 아니라, 위치가 변했을 때만 즉시 신호를 보내고 처리하는 구조가 필요하다.
- **디스크에서 메모리로:** 물리적 디스크 I/O와 MVCC의 무거움을 극복하기 위해, 모든 처리를 메모리 상에서 수행하여 지연 시간을 마이크로초 단위로 줄일 수 있는 Redis와 같은 인메모리 저장소 도입이 필수적이다.
