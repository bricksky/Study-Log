## 1. Kafka가 너무 무겁다면, Redis 안에서 해결하자

---

Apache Kafka가 대규모 이벤트 처리에 강력하지만, 분산 클러스터 관리와 디스크 기반 저장 방식이 실시간 위치 데이터(휘발성 데이터) 처리에는 다소 과하고 무겁다는 점을 확인했다. "단순 위치 알림을 위해 이렇게 큰 시스템을 관리해야 하나? 이벤트 기반의 장점은 가져가되, 운영은 더 가볍게 할 수 없을까?"라는 고민 끝에 찾은 해답이 바로 Redis Streams다.

Redis 5.0부터 추가된 이 기능은 Kafka의 핵심 장점인 '이벤트 기록' 기능을 갖추고 있으면서도, 별도의 설치 없이 기존 Redis 안에서 바로 쓸 수 있었다. "이거다!" 싶었다. Kafka처럼 거대하지 않으면서도, 내가 필요로 하는 실시간 이벤트 처리를 완벽하게 지원하기 때문이다.

- **Redis Streams:** Redis에서 제공하는 로그 형태의 데이터 구조다. 한 번 저장된 데이터는 수정되지 않고 끝에 계속 추가되며, 각 데이터에는 시간 정보를 포함한 고유 ID가 자동으로 부여된다. 메시지 브로커의 기능과 데이터 저장소의 기능을 동시에 수행하며, 특히 실시간 시계열 데이터를 처리하는 데 특화되어 있다.
- **이벤트 스트리밍:** 비즈니스에서 발생하는 수많은 사건(이벤트)을 실시간으로 포착하여 필요한 곳으로 즉시 전달하고 처리하는 기술 패러다임이다. LBS에서는 라이더의 '좌표 변경'이 하나의 핵심 이벤트가 되며, 이를 스트림에 태워 보냄으로써 알림 서버나 계산 엔진이 즉각 반응할 수 있게 만든다.
- **소비자 그룹 :** 하나의 데이터 스트림을 여러 개의 클라이언트(소비자)가 협력하여 처리하기 위한 논리적인 묶음이다. 스트림에 쌓인 메시지를 그룹 내 멤버들이 중복되지 않게 나누어 처리함으로써 시스템의 처리량을 수평적으로 확장할 수 있게 해준다.

</br>

### 1.1 왜 Redis Streams인가? - 경량화와 고성능의 조화

<img width="714" height="392" alt="image" src="https://github.com/user-attachments/assets/cddd415d-c7cb-4d66-b497-7546e5fb10e9" />


Redis 5.0부터 도입된 Streams 데이터 타입은 Kafka의 핵심 설계 철학인 'Append-only Log' 구조를 인메모리(RAM) 환경에 구현한 것이다.

- **인프라 통합:** Kafka를 쓰려면 별도의 브로커 서버와 관리 도구(ZooKeeper 등)를 띄워야 하지만, Streams는 이미 사용 중인 Redis 인스턴스 내에서 하나의 데이터 타입으로 동작한다. 추가적인 설치나 복잡한 네트워크 설정 없이 바로 이벤트 스트리밍 환경을 구축할 수 있다는 점이 가장 큰 매력이었다.
- **인메모리의 속도:** 모든 데이터를 디스크에 기록하는 Kafka와 달리, Redis Streams는 메모리상에서 동작하므로 지연 시간이 극도로 짧다. 실시간 위치 좌표처럼 빠르게 발생하고 사라지는 데이터를 처리하기에 최적의 성능을 보여준다.

</br>

### 1.2 내부 동작 원리: 어떻게 이벤트를 관리하는가?

Redis Streams는 데이터를 단순히 저장하는 것이 아니라, 발생한 순서대로 엔트리 ID(타임스탬프 기반)를 부여하여 관리한다.

1. **데이터 적재:** 라이더의 좌표가 발생하면 `XADD` 명령어를 통해 스트림에 데이터를 넣는다. 이때 데이터는 메모리 효율을 극대화하기 위해 Radix Tree와 listpack이라는 특수한 구조로 저장된다.
2. **소비자 그룹:** Kafka의 가장 강력한 기능 중 하나인 '소비자 그룹'을 Redis Streams도 지원한다. 이를 통해 여러 대의 서버(워커)가 하나의 스트림에서 데이터를 나누어 가져가 병렬로 처리할 수 있다. 예를 들어, 1번 워커는 라이더 A의 좌표를 처리하고, 2번 워커는 라이더 B의 좌표를 처리하는 식이다.

</br>

### 1.3 연구적 가치: 휘발성 데이터에 최적화된 설계

가장 인상 깊었던 기능은 스트림 크기 제한(MAXLEN) 설정이다. Kafka는 데이터를 디스크에 영구히 저장하려는 성격이 강하지만, Redis Streams는 `XADD stream_name MAXLEN 1000 * ...`과 같은 명령으로 최신 1,000개의 데이터만 남기고 오래된 데이터는 자동으로 버릴 수 있다. 이는 "과거의 좌표보다 현재의 위치가 중요한" LBS 연구에서 저장 공간을 효율적으로 관리할 수 있는 결정적인 기능이다

</br>
</br>
</br>


## 2. 지도는 왜 꼭 사각형이어야 할까? - Uber H3의 등장

---

앞서 배운 Geohash(지오해시)는 지도를 사각형으로 나눈다. 하지만 공부를 해보니 사각형에는 치명적인 약점이 있었다. 내 위치를 기준으로 주변 라이더를 찾을 때, 상하좌우에 있는 라이더와의 거리와 대각선에 있는 라이더와의 거리가 다르다는 점이다.

이 문제를 해결하기 위해 Uber에서 만든 H3라는 육각형 그리드시스템을 공부했다. 육각형은 중심에서 인접한 6개 칸까지의 거리가 모두 동일하다. 덕분에 배달 앱에서 "반경 1km 이내 라이더 찾기" 같은 연산을 할 때 훨씬 정확하고 빠르다. 특히 지오해시의 고질병인 '경계선 문제'를 수학적으로 깔끔하게 해결했다는 점이 소름 돋게 신기했다.

- **그리드:** 지도를 일정한 격자 모양으로 나눈 것을 말한다. 위도와 경도라는 연속적인 좌표 데이터를 격자 번호라는 이산적인 데이터로 변환함으로써, 데이터베이스가 공간 데이터를 훨씬 빠르게 인덱싱하고 검색할 수 있게 돕는다.
- **Uber H3**: 지구 전체를 육각형 타일로 덮는 계층적 공간 인덱싱 시스템이다. 64비트 정수 하나로 지구상의 특정 지점과 그 크기(해상도)를 나타낼 수 있다. 육각형 구조의 특성상 인접 탐색이 매우 빠르고 정확하여, 우버의 배차 알고리즘, 경로 최적화, 수요 예측 등에 핵심적으로 사용된다. 우버(Uber)가 효율적인 배차를 위해 개발하여 오픈소스로 공개했다.
- **k-ring 탐색:** 특정 육각형 칸을 기준으로 주변 n단계 인접한 칸들을 한꺼번에 찾는 방식이다. 육각형 구조 덕분에 연산이 매우 단순해진다.
- **경계선 문제:** 공간 분할 방식에서 물리적으로는 매우 가까운 두 지점이 서로 다른 격자 영역에 속하게 되어, 시스템상에서 마치 멀리 떨어진 데이터처럼 취급되는 현상이다. 사각형 기반의 Geohash는 이 문제가 심각하여 주변 8개 칸을 항상 추가 조회해야 하는 비용이 발생하지만, H3는 육각형의 대칭성을 활용해 이를 훨씬 효율적으로 처리한다.

</br>

### **2.1 사각형 그리드의 한계: 이웃 간 거리의 불균형**

사각형 그리드(Square Grid)에서 특정 칸의 중심으로부터 인접한 칸들의 중심까지 거리를 계산해 보면 수학적인 문제점이 드러난다.

- **거리의 불일치:** 사각형은 변을 맞대고 있는 이웃(4개)과의 거리는 1이지만, 꼭짓점을 맞대고 있는 대각선 이웃(4개)과의 거리는 **√**2약 1.414가 된다.
- **연산의 복잡도:** 배달 앱에서 "반경 1km 이내 라이더"를 찾을 때, 사각형 격자를 사용하면 원형 범위를 계산하기 위해 복잡한 삼각함수 연산을 매번 수행하거나, 불필요하게 넓은 사각형 영역을 먼저 조회한 뒤 필터링해야 한다. 이는 시스템 자원을 소모하는 원인이 된다.

</br>

### 2.2 Uber H3: 육각형이 주는 위상학적 균일성

Uber에서 오픈소스로 공개한 **H3**는 지도를 정육각형으로 분할한다. 육각형 그리드는 사각형의 문제를 완벽하게 해결한다.

- **동일한 이웃 거리:** 육각형은 인접한 6개의 모든 칸과 동일한 길이의 변을 공유한다. 따라서 중심점에서 인접한 모든 이웃 칸의 중심까지의 거리가 1로 동일하다.
- **원형 근사 최적화:** 여러 개의 육각형을 모으면 사각형보다 훨씬 원형에 가까운 모양이 만들어진다. 덕분에 "특정 반경 내 검색"을 수행할 때 좌표 기반의 복잡한 연산 대신, 단순히 H3 인덱스(정수) 간의 집합 연산만으로도 매우 정확한 결과를 얻을 수 있다.

</br>

### 2.3 경계선 문제(Boundary Issue)의 수학적 해결

Geohash를 공부할 때 가장 골치 아팠던 것이 '아주 가까운 두 점이 격자 경계에 걸리면 해시값이 완전히 달라지는 현상'이었다. H3는 이를 계층적 인덱싱 구조로 해결한다.

지구 전체를 정이십면체로 투영한 뒤, 각 면을 육각형으로 쪼개어 내려가는 방식을 취한다. 만약 사용자가 경계선 근처에 있다면, H3는 k-ring이라는 알고리즘을 통해 주변 육각형들을 인덱스 연산만으로 즉시 찾아낸다. 위도에 따른 면적 왜곡도 사각형보다 훨씬 적어, 고위도 지역에서도 서비스 품질을 일정하게 유지할 수 있다는 점이 놀라웠다.

</br>
</br>
</br>


## 3. Redis도 SQL처럼 똑똑해질 수 있다 - RediSearch

---

2주차에 Redis의 단점으로 꼽았던 "복합 검색의 어려움"을 해결해 줄 해결책을 찾았다. 단순히 위도/경도로 주변 라이더를 찾는 것은 가능했지만, 거기에 "배달 중인 라이더는 제외", "평점 4.5 이상만" 같은 비즈니스 조건을 섞는 순간 성능이 급격히 떨어졌다. 이를 해결하기 위해 Redis의 기능을 확장해 주는 RediSearch 모듈을 심층적으로 공부했다.

이걸 쓰면 Redis에 저장된 데이터에 '역색인(Inverted Index)'을 만들 수 있다. "강남역 주변(위치) + 활동 중(상태) + 오토바이(수단)" 같은 여러 조건을 동시에 필터링하는 게 가능하다. 이전에는 앱에서 일일이 코딩해서 걸러내야 했던 복잡한 작업들을, 이제 Redis가 내부에서 직접 처리해서 결과만 딱 보내준다. "레디스는 단순하다"는 내 편견이 완전히 깨지는 순간이었다.

- **역색인 (Inverted Index):** 키워드를 통해 해당 키워드가 포함된 문서를 찾아내는 방식의 데이터 구조다. 책의 맨 뒤에 있는 '색인(Index)' 페이지에서 특정 단어를 찾으면 해당 단어가 나오는 페이지 번호들이 적혀 있는 것과 같은 원리다. 검색 엔진(Elasticsearch 등)의 핵심 기술이며, RediSearch는 이를 메모리상에서 구현하여 극강의 속도를 낸다.
- **모듈:** Redis 본체(Core)의 기능을 확장하기 위해 별도로 제작된 부품 프로그램이다. Redis는 C언어로 작성되어 매우 빠른데, 모듈 역시 C나 Rust 같은 고성능 언어로 작성되어 Redis 엔진에 직접 통합된다. 덕분에 라이브러리를 쓰는 것보다 훨씬 빠르고 효율적으로 새로운 기능을 수행할 수 있다.
- **복합 질의:** 하나가 아닌 여러 개의 조건(예: 위치 AND 상태 AND 시간)을 조합하여 데이터를 조회하는 방식이다. 단순한 Key-Value 저장소는 한 번에 하나의 키만 찾을 수 있지만, RediSearch와 같은 엔진은 여러 인덱스를 동시에 검색하고 그 결과를 논리 연산(AND, OR, NOT)으로 결합하여 사용자에게 제공한다.
- **스키마:** RediSearch를 쓰기 위해서는 어떤 필드(위치, 이름, 평점 등)를 인덱싱할지 미리 정의해야 한다. 이를 통해 Redis는 각 필드의 특성에 맞는 최적의 알고리즘(공간용 R-Tree, 숫자용 계층 구조 등)을 적용하여 검색 효율을 극대화한다.
- **데이터 근접 연산:** 데이터를 다른 곳으로 옮겨서 처리하는 게 아니라, 데이터가 저장된 바로 그 장소(Redis 메모리 안)에서 연산을 수행하는 개념이다. 전송 오버헤드를 줄이는 현대 분산 시스템의 핵심 설계 원칙 중 하나다.

</br>

### 3.1 Fetch-then-Filter 문제의 근본적인 해결

기존 Redis 구조에서는 모든 데이터를 서버 애플리케이션으로 가져온 뒤 코드상에서 필터링하는 '과다 조회’가 불가피했다. 이는 네트워크 대역폭을 낭비하고 지연 시간을 늘리는 주범이었다.

- **RediSearch의 역할:** Redis 내부에서 데이터가 저장되는 방식 외에 별도의 '보조 인덱스'를 관리한다.
- **데이터 근접 연산:** 이제 서버가 "강남역 주변 + 활동 중 + 평점 4.5 이상"이라는 명령을 던지면, Redis가 자기 메모리 안에서 인덱스들을 교차시켜 최종 결과값만 서버에 전달한다. 결과적으로 네트워크를 타고 흐르는 데이터 양이 획기적으로 줄어들고 서버의 CPU 부하도 감소한다.

</br>

### 3.2 핵심 기술: 인메모리 역색인(Inverted Index)

RediSearch가 SQL처럼 복합 검색을 빠르게 수행할 수 있는 비결은 역색인(Inverted Index) 구조에 있다.

- **동작 원리:** 일반적인 데이터베이스가 `ID -> 데이터` 순으로 저장한다면, 역색인은 `속성(값) -> 해당 속성을 가진 ID 목록` 순으로 저장한다.
- **검색 효율:** 예를 들어 '활동 중(Active)'이라는 키워드에 속한 라이더 ID 리스트와 '강남구'에 속한 라이더 ID 리스트를 미리 만들어두는 것이다. 검색 시에는 두 리스트의 교집합만 찾으면 되기 때문에 데이터가 수백만 건이라도 연산 속도는 O(1) 혹은 O(log N)수준을 유지한다.

</br>

### 3.3 위치와 속성의 통합 인덱싱

RediSearch는 단순 텍스트뿐만 아니라 공간 데이터(GEO)와 숫자(NUMERIC), 태그(TAG) 필드를 동시에 지원한다.

1. **공간 필터:** H3 인덱스나 위도/경도 반경을 기준으로 1차 필터링을 수행한다.
2. **동시 필터링:** 공간 연산과 동시에 '상태'와 '평점' 조건을 인덱스 수준에서 결합한다.
3. **실시간 갱신:** 라이더의 상태가 바뀌면 RediSearch 모듈이 백그라운드에서 실시간으로 역색인을 갱신해주므로, 개발자가 수동으로 인덱스를 관리하는 수고를 덜어준다.

</br>
</br>
</br>

## 4. "이 기술들을 어떻게 엮을 것인가?" (Architecture Design)

---

이제 공부한 조각들을 하나로 합쳐봤다. 라이더가 위치를 쏘면 내 시스템은 이렇게 움직일 것이다.

1. Ingestion: 라이더의 GPS 좌표가 Redis Streams에 '이벤트'로 들어온다.
2. Conversion: 작업자(Worker)가 이 좌표를 받아서 Uber H3 육각형 주소로 변환한다. (예: 강남역 9번 출구 -> `8928308280fffff`)
3. Storage & Indexing: 변환된 H3 주소와 상태 정보를 Redis에 저장하면, RediSearch가 자동으로 인덱스를 만든다.
4. Notification: 사용자가 주변 라이더를 찾으면, RediSearch가 육각형 인덱스를 이용해 0.001초 만에 결과를 뽑아준다.

이 아키텍처라면 RDBMS의 락 경합도 없고, Kafka의 운영 부담도 없으며, Redis의 쿼리 한계도 극복할 수 있다는 확신이 들었다.

- **수동 인덱싱 vs 자동 인덱싱:**
    - **수동:** 라이더 상태가 '활동 중'에서 '휴식 중'으로 바뀌면, 개발자가 기존 '활동' 목록에서 삭제하고 '휴식' 목록에 추가하는 코드를 직접 짜야 한다. 실수하면 데이터가 꼬인다.
    - **자동:** RediSearch가 제공하는 방식이다. 데이터 자체(`status: active`)만 수정하면 시스템이 내부적으로 관리하는 검색용 목차(인덱스)를 알아서 고친다. 개발자는 비즈니스 로직에만 집중할 수 있고 데이터 정합성 유지도 훨씬 쉬워진다.
- **지연 시간:** 데이터가 입력되어 결과가 나올 때까지 걸리는 시간. 이번 연구의 목표는 이 지연 시간을 '밀리초(ms)' 단위로 줄이는 것이다. LBS에서는 "라이더가 움직인 시점"부터 "내 폰의 아이콘이 움직이는 시점"까지의 총 시간을 의미한다. 1주차에 배운 폴링 방식은 '폴링 주기'라는 인위적인 지연 시간이 생기지만, 이 이벤트 기반 아키텍처는 데이터가 흐르는 물리적인 시간(거의 밀리초 단위)만 소요된다.
- **Ingestion:** 외부에서 발생하는 대량의 데이터를 시스템 내부로 받아들이는 입구 단계다. 실시간 시스템에서는 입구가 막히면 전체 시스템이 마비되므로, Redis Streams 같은 고성능 큐를 배치하여 데이터를 빠르고 안전하게 받아내는 것이 중요하다

</br>

### 4.1 데이터 흐름의 4단계 (Pipeline)

**1단계: 데이터 수집 - "폭주하는 데이터를 안정적으로 수신"**

라이더의 GPS 좌표가 초당 수만 건씩 쏟아질 때, 이를 곧바로 검색 엔진이나 DB에 넣으면 병목이 생긴다.

- **구조:** 입구에서 Redis Streams가 '이벤트'를 가장 먼저 맞이한다.
- **효과:** Kafka처럼 거대하지 않지만, 메모리 기반으로 동작하여 수신 지연 시간이 거의 없다. 일단 스트림에 쌓아두기 때문에, 뒤쪽의 연산 과정이 잠시 늦어져도 데이터가 유실되지 않는 '완충 작용'을 해준다.

**2단계: 공간 변환 - "좌표를 육각형 주소로 변경"**

스트림에 쌓인 원본 좌표(위도, 경도)는 그대로 쓰기에는 계산량이 많다.

- **구조:** 백그라운드에서 동작하는 작업자가 스트림의 데이터를 하나씩 꺼내 Uber H3 라이브러리를 통해 육각형 인덱스(64비트 정수)로 변환한다.
- **효과:** 예컨대 '강남역 9번 출구' 좌표가 `8928308280fffff`라는 고유한 번호로 바뀐다. 이제 복잡한 소수점 연산 대신, 이 번호만 보고 "같은 육각형 안에 있네?" 혹은 "옆 칸 육각형이네?"라고 아주 쉽게 판단할 수 있게 된다.

**3단계: 저장 및 자동 인덱싱 - "검색을 위한 준비"**

변환된 H3 주소와 라이더의 상태(활동 중, 배달 중 등)를 Redis의 Hash나 JSON 구조로 저장한다.

- **구조:** 이때 **RediSearch**가 미리 설정된 규칙에 따라 이 데이터를 실시간으로 감시한다.
- **효과:** 데이터가 저장되자마자 RediSearch는 **자동 인덱싱**을 수행한다. 개발자가 "이 라이더는 활동 중이니까 활동 중 목록에 넣어줘"라고 일일이 코딩할 필요 없이, 저장만 하면 검색을 위한 '역색인 목록'이 순식간에 갱신된다.

**4단계: 알림 및 조회 - "0.001초 만의 응답"**

마침내 사용자가 앱을 켜서 "주변 오토바이 라이더 보여줘"라고 요청한다.

- **구조:** RediSearch는 이미 만들어진 육각형 인덱스와 상태 인덱스를 교차시켜 결과를 뽑아낸다.
- **효과:** 메모리 안에서 인덱스만 훑기 때문에 지연 시간(Latency)은 0.001초(1ms) 내외로 떨어진다. RDBMS의 락 경합이 발생할 틈도 없고, 앱에서 데이터를 가져와 거르는 노가다도 사라진다.

</br>

### 4.2 "왜 이 조합이 정답인가?"

이 아키텍처를 설계하며 나는 세 가지 확신을 얻었다.

1. **가벼운 운영:** Kafka 클러스터 없이 Redis 하나(혹은 클러스터)만으로 이벤트 처리가 가능하다.
2. **정확한 공간 연산:** 사각형의 왜곡 없이 육각형(H3)으로 정확한 반경 검색을 수행한다.
3. **지능적인 검색:** RediSearch 덕분에 SQL 못지않은 복잡한 필터링을 메모리 속도로 처리한다.

</br>
</br>
</br>


## 5. 결론

---

처음에는 막연히 "배달 앱 지도"가 신기해서 시작했는데, 공부하다 보니 그 이면에 수학적 육각형 시스템(H3)과 고도의 실시간 스트리밍 기술(Streams)이 숨어 있다는 걸 알게 되어 정말 즐거웠다.

1. **Redis Streams:** Kafka의 복잡함을 덜어낸 가벼운 이벤트 엔진. 인메모리의 속도로 위치 데이터를 수집하고 소비자 그룹을 통해 안정적으로 분산 처리한다.
2. **Uber H3:** 사각형 그리드의 거리 왜곡을 해결한 육각형 계층 인덱스. 복잡한 삼각함수 연산을 단순한 정수 비교 연산으로 치환하여 공간 연산 효율을 극대화한다.
3. **RediSearch:** Redis의 단순한 Key-Value 구조에 '지능(역색인)'을 부여하는 엔진. 실시간 위치와 비즈니스 조건을 메모리 안에서 동시에 필터링하여 지연 시간을 획기적으로 단축한다.
