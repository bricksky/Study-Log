### "왜 데이터가 쌓일수록 시스템이 느려질까?"
> 🔗 **관련 PR**: [RDBMS 공간 데이터 처리 및 PostGIS 지원 추가](https://github.com/ICN-Soongsil/LBS-project/pull/20)
>



> 이번 글에서는 전통적인 데이터 처리 방식인 RDBMS 접근법과 대용량 트래픽 처리에 특화된 Kafka 기반 접근법을 직접 구현하고 비교한 과정을 정리한다. 단순히 무엇이 더 빠르다는 결론을 넘어, 각 기술이 데이터 정합성과 처리량 사이에서 어떤 트레이드오프를 가졌는지 분석하고 상황에 맞는 최적의 선택지를 고민해 보았다.
> 

**리팩토링 요약**

- 배경: 데이터 증가에 따른 동기 방식의 응답 지연 및 처리량 한계 인지
- 핵심: PostgreSQL 기반 동기 처리와 Kafka 기반 비동기 처리의 이중 구현 및 비교
- 결과: 시스템 요구사항에 따른 저장소 및 처리 메커니즘의 선택 기준 확립

---

</br>

### 1. RDBMS 접근 방식: "안전하지만 정직한 기다림"

<img width="4508" height="839" alt="image (4)" src="https://github.com/user-attachments/assets/81f2097c-d5b6-4c75-b744-0a91d92dffaa" />




가장 먼저 구현한 방식은 PostgreSQL과 PostGIS를 활용한 전통적인 동기 처리 구조다. 
이 방식은 마치 창구 직원이 업무 처리를 완전히 완료할 때까지 고객이 앞에서 기다려야 하는 은행 시스템과 같다.

<img width="733" height="446" alt="스크린샷 2026-02-10 오후 2 00 57" src="https://github.com/user-attachments/assets/0516896d-2fdb-45a6-9cea-f89a68a5daf5" />



**🔄 흐름 상세 설명**

- **요청 도착:** 클라이언트 역할을 하는 파이썬 스크립트가 POST /update 경로로 위치 데이터를 전송한다.
- **동기 처리와 블로킹:** 서버는 요청을 받는 즉시 데이터베이스에게 쓰기 작업을 명령한다. 이때 서버는 데이터베이스가 처리를 완료하고 응답을 줄 때까지 다른 일을 하지 못하고 멈춰 서서 기다린다.
- **디스크 기반 트랜잭션:** 데이터베이스는 유저 존재 여부를 확인하고 상황에 따라 생성 혹은 갱신 작업을 수행한다. 이 과정은 하드디스크에 물리적으로 기록되어야 하므로 메모리 작업보다 상대적으로 긴 시간이 소요된다.
- **응답 전송:** 모든 저장이 완료되어 커밋 신호가 떨어지면 서버는 그제야 클라이언트에게 성공 응답을 보낸다.

**🎯 특징과 한계**

이 방식의 최대 강점은 데이터 무결성이다. 저장 직후 조회해도 데이터가 100% 존재함을 보장하는 즉시 일관성을 제공한다. 하지만 트래픽이 몰리면 데이터베이스 병목 현상이 발생하여 클라이언트가 응답을 받기까지 대기 시간이 길어지는 치명적인 약점이 있다

---

</br>

### 2. Kafka 접근 방식: "접수는 빠르게, 처리는 묵묵하게"
<img width="7273" height="1459" alt="image (5)" src="https://github.com/user-attachments/assets/e3906353-c6bb-4c3c-9c43-2ce3878c4ca8" />



두 번째로 구현한 방식은 Kafka와 Redis를 결합한 비동기 처리 구조다. 이는 고객이 주문만 하고 진동벨을 받아 떠나면, 주방에서 별도로 요리를 진행하는 스타벅스 시스템에 비유할 수 있다.

<img width="736" height="347" alt="스크린샷 2026-02-10 오후 2 01 37" src="https://github.com/user-attachments/assets/a8bb080f-dae8-4c76-aa6d-4cba8b66a6a8" />




**🔄 흐름 상세 설명**

이 구조는 데이터가 들어오는 시점과 실제로 저장되는 시점이 분리된 두 단계의 타임라인을 가진다.

**Phase 1. 접수 단계** 

- 서버는 데이터를 받자마자 이를 Kafka 토픽이라는 공용 우체통에 집어넣는다.
- **즉시 응답:** 실제 저장이 완료되지 않았더라도 서버는 접수 완료를 의미하는 202 Accepted 응답을 클라이언트에게 즉시 돌려준다. 클라이언트는 기다릴 필요 없이 다음 데이터를 바로 보낼 수 있어 전체적인 처리량이 비약적으로 상승한다.

**Phase 2. 처리 단계**

- **비동기 소비:** 백그라운드에서 상시 대기 중인 컨슈머가 Kafka에서 데이터를 하나씩 꺼내온다.
- **인메모리 저장:** 꺼낸 데이터는 디스크가 아닌 메모리 기반 저장소인 Redis에 기록된다. 마이크로초 단위의 빛의 속도로 처리가 완료되므로 실시간 관제에 최적화된 속도를 보여준다.

**🎯 특징과 한계**

서버가 터지지 않고 거대한 데이터 파도를 받아낼 수 있는 높은 처리량이 최대 장점이다. 다만 시스템 구성이 복잡해지고, 접수 시점과 저장 시점 사이에 아주 미세한 시차가 존재하는 최종 일관성 모델을 따른다는 점을 고려해야 한다.

---

</br>

### 3. 기술 결정의 척도: RDBMS vs Kafka

두 가지 방식을 직접 구현하며 체감한 차이를 아래와 같이 정리했다.

| **구분** | **RDBMS 방식** | **Kafka 방식** |
| --- | --- | --- |
| **처리 방식** | 직렬 처리 | 병렬 처리 |
| **클라이언트 상태** | 저장 완료까지 대기 | 접수 후 즉시 해제 |
| **주요 저장소** | Disk (안전함) | Memory (빠름) |
| **핵심 가치** | 데이터 정확성 및 무결성 | 시스템 가용성 및 처리량 |
| **적합한 사례** | 결제, 회원 정보 관리 | 위치 추적, 로그 수집, 채팅 |
