### "우리 시스템의 위치 계산 결과가 국제 표준에서도 유효함을 입증할 수 있는가?"
> 🔗 **관련 PR**: [Redis 및 Kafka 위치 데이터 처리 기능 추가](https://github.com/ICN-Soongsil/LBS-project/pull/13)
>
> ICN 연구과제의 핵심 성과 중 하나인 OGC 벤치마크 등록을 위해, 지리 공간 데이터 처리의 정확성을 국제적 기준에 맞추는 작업이 필요했다. 단순히 두 점 사이의 거리를 구하는 것을 넘어, OGC에서 요구하는 오차 범위 내의 정밀도를 확보하는 것이 관건이었다. 이에 구면 삼각법의 표준인 하버사인 공식을 도입하고, pip 쿼리문으로 추출한 고차원 좌표 데이터를 정밀한 물리적 거리로 변환하여 시스템의 신뢰성을 국제 표준 수준으로 끌어올린 과정을 정리한다.


---

**리팩토링 요약**

- 배경: OGC 벤치마크 등록을 위한 지리 정보 처리의 정확도 및 표준 준수 필요
- 핵심: 하버사인 공식을 활용한 구면 거리 산출 로직의 표준화
- 결과: 국제 표준 벤치마크 요구 사항 충족 및 위치 기반 데이터의 공신력 확보

</br>

### 1. 문제 상황: "국제 표준(OGC)이라는 높은 문턱"

연구과제 성과를 증명하기 위해서는 공간 정보 표준화 기구인 OGC의 벤치마크를 통과해야 했다. 기존의 단순 수치 비교 방식은 지구 곡률에 따른 오차를 계산에 넣지 않았기에, 정밀한 공간 연산을 평가하는 벤치마크 테스트에서 불합격 요인이 될 가능성이 컸다.

**표준 등록을 위한 필수 요건**

- 수학적 검증 가능성: 단순히 라이브러리를 쓰는 것이 아니라, 검증된 공식에 기반한 계산 절차가 명확해야 함
- 정밀도 유지: 위도에 따른 경도 거리 변화량이 계산 결과에 정확히 반영되어야 함

기존 데이터 엔진에서 pip 쿼리문으로 가져온 방대한 좌표 셋을 어떻게 하면 표준 규격에 맞는 거리 정보로 가공할 것인지가 기술적 해결 과제였다.

</br>

### 2. 하버사인 공식: 표준을 향한 수학적 교두보

OGC 벤치마크는 실제 지표면상의 물리적 거리와 시스템 계산 결과의 일치성을 엄격히 따진다. 나는 평면 좌표계의 오차를 극복하기 위해 하버사인 공식을 선택했다. 이 공식은 중심각을 이용하여 구 위의 두 점 사이의 거리를 구하는 방식으로, 표준화된 지리 정보 시스템 구축에 가장 적합한 모델이다.

비유하자면, 평면 지도 위에 자를 대는 방식에서 벗어나, 실제 지구본 위에 실을 팽팽하게 당겨 거리를 재는 '입체적 측정' 방식으로 전환한 것이다.

</br>

### 3. 구현 전략: 쿼리 결과의 정밀 가공

데이터베이스 쿼리를 통해 최적화된 속도로 좌표를 수신한 뒤, 서비스 레이어에서 하버사인 로직을 적용하여 최종 결과값을 산출하는 구조를 설계했다.

**Step 1. 고정밀 상수 정의 및 라디안 변환**

OGC 표준에 근거하여 지구의 평균 반지름을 설정하고, 모든 도 단위 데이터를 라디안으로 정밀하게 변환한다.

```java
public final class GeoLocationCalculator {

// OGC 벤치마크 기준에 부합하는 지구 평균 반지름 (km)

private static final double EARTH_RADIUS_KM = 6371.0088;

`public static double getDistance(double lat1, double lon1, double lat2, double lon2) {
    double phi1 = Math.toRadians(lat1);
    double phi2 = Math.toRadians(lat2);
    double deltaPhi = Math.toRadians(lat2 - lat1);
    double deltaLambda = Math.toRadians(lon2 - lon1);

    double a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +
               Math.cos(phi1) * Math.cos(phi2) *
               Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
               
    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return EARTH_RADIUS_KM * c;
}`

}
```

**Step 2. pip 쿼리문 연동 및 대량 데이터 처리**

데이터베이스에서 pip 쿼리로 필터링된 유효 좌표들을 스트림으로 넘겨받아 위 로직에 투입했다. 이를 통해 수만 건의 위치 데이터에 대한 거리 산출을 밀리초 단위로 수행하면서도 정확도를 유지할 수 있었다.

</br>

### 4. 왜 이렇게 설계했는가?

**4.1 왜 OGC 벤치마크에 하버사인이 유리한가?**

대부분의 오픈소스 공간 데이터베이스 엔진도 내부적으로 하버사인 혹은 빈센티 공식을 사용한다. 애플리케이션 레벨에서 하버사인 로직을 직접 관리함으로써, 데이터베이스 엔진의 버전에 의존하지 않고도 항상 일정한 벤치마크 결과값을 얻을 수 있는 환경을 구축했다.

**4.2 쿼리(pip)와 로직의 역할 분담**

데이터베이스는 pip(Point in Polygon) 쿼리를 통해 유효한 범위 내의 데이터만 빠르게 추출하는 '거름망' 역할을 수행하고, Java 애플리케이션은 추출된 데이터에 대해 정밀한 수학적 연산을 수행하는 '정밀 가공' 역할을 맡았다. 이러한 역할 분리는 전체 시스템의 처리 효율과 유지보수성을 극대화한다.

</br>

### 5. 결론: "표준은 기술의 언어다"

이번 작업을 통해 OGC 벤치마크 등록을 위한 기술적 토대를 마련할 수 있었다. 단순히 거리를 구하는 기능의 구현을 넘어, 국제 표준이 요구하는 엄격한 기준을 충족하기 위해 로직을 다듬는 과정은 백엔드 개발자로서 '정확성'과 '신뢰성'이라는 가치를 다시금 되새기는 계기가 되었다.
