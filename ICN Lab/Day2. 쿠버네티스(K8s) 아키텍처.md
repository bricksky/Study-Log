## 1. 애플리케이션 실행 환경의 변화와 등장 배경

---

애플리케이션의 배포 방식은 전통적 환경 → 가상 환경 → 컨테이너 환경의 3단계를 거쳐 진화해왔다.

<img width="524" height="279" alt="image" src="https://github.com/user-attachments/assets/44fb2514-78a5-45d2-ba7e-2d516113a851" />


- 1단계: 전통적 배포(On-premise)
    - 물리 서버에서 실행하므로 변경 적용이 어렵고 유지관리 비용이 높다
    
      <img width="436" height="156" alt="image" src="https://github.com/user-attachments/assets/5dc4ef4d-fd36-445e-8653-fbcb3e2594b9" />

    
- 2단계: 가상 환경 배포(VM)
    - 단일 물리 서버에서 여러 VM을 싱행하며, 앱 간 격리와 보안은 좋으나 OS부팅이 무겁다
        
      
      <img width="368" height="292" alt="image" src="https://github.com/user-attachments/assets/36088b0e-2793-4b03-abbe-3c5effee2499" />

        
    
- 3단계: 컨테이너 배포(Container)
    - VM과 유사하나 OS를 공유하여 가볍고 이식성이 높아 현재 많이 사용하는 방식이다
        
      
      <img width="624" height="266" alt="image" src="https://github.com/user-attachments/assets/0d4d2f95-2bd5-469e-9c5a-d9aaab34315f" />

        

### 컨테이너 기술의 장점과 도커의 등장

컨테이너는 프로세스 단위의 격리 환경을 조성하고 있어서 상호 간의 의존도를 낮춰준다. 또한 VM에 비해 사이즈가 작아서 배포가 빠르고 성능 손실이 거의 없다. 다양한 컨테이너 런타임 기술이 있으며 도커가 사실상의 표준이다

### **도커 컨테이너로 서비스를 한다는 것은?**

도커 컨테이너로 서비스를 하게 되면 하나의 도커 이미지 안에 서비스 운영에 필요한 모든 것들이 들어 있어 협업에 용이하다. 또한 서비스 운영 환경과 개발 환경의 느슨한 결합으로 한쪽에서 에러가 발생해도 다른 한쪽은 작업을 이어나갈 수 있다. 도커 컨테이너는 배포가 빠르고 쉬우며 시스템 의존성을 쉽게 업그레이드 할 수 있어서 스케일 아웃에 용이하다. CPU limit, Memory limit 등의 시스템 자원을 효율적으로 활용할 수가 있고 무엇보다도 가상머신 보다 성능 면에서 뛰어나다.

하지만, 컨테이너화된 애플리케이션도 역시 관리를 해야하는데, 컨테이너화된 어플리케이션이 다운되면 직접 재실행시켜야한다.

<img width="700" height="229" alt="image" src="https://github.com/user-attachments/assets/251ac643-13e1-4802-8df1-ce5457cb5b1c" />


전통적인 방식과 VM보다 관리가 용이하지만 컨테이너의 스케일 아웃 장점으로 인해 관리해야하는 컨테이너의 수가 많아지게 되면 또 해결해야한다는 특징이 있다.

### **오케스트레이션(Container Orchestration)이란?**

수많은 연주자들이 지휘에 맞춰 연주하는 것을 “오케스트라”라고 한다.

컨테이너 오케스트레이션은 말 그대로 컨테이너를 지휘하는 메인 컨트롤러가 있고, 그 지휘에 맞춰 컨테이너의 배포, 관리, 확장, 네트워킹을 자동화하는 것을 의미한다. 컨테이너를 사용하는 어떤 환경에서든 사용할 수 있다.

<img width="702" height="287" alt="image" src="https://github.com/user-attachments/assets/5ebb54b7-cccc-4eea-adff-85a8f07b9c56" />


### 컨테이너의 계층 구조

<img width="560" height="353" alt="image" src="https://github.com/user-attachments/assets/a65a7e5c-3c80-4194-9873-2951d60677f1" />


컨테이너 상위 계층에 오케스테이션이 위치한다.

5개의 도커 엔진으로 구현되고 있는 컨테이너를 재설계할 필요 없이 각기 다른 환경 전반에 동일한 애플리케이션을 배포하는데 도움이 된다.

### **쿠버네티스 (Kubernetes)란?**

쿠버네티스란 구글이 내부 플랫폼 Brog를 운영하며 축적한 경험을 바탕으로 설계한 오픈소스 플랫폼이다.

실제 프로덕션 환경에서의 애플리케이션들은 여러 컨테이너에 걸쳐 있으며 이러한 컨테이너는 여러 서버 호스트에 배포되어야 한다. 이 때문에 컨테이너를 위한 보안은 멀티 레이어구조로 되어있고 복잡하다, 이때 쿠버네티스가 활용된다. 쿠버네티스는 워크로드를 위해 규모에 맞는 컨테이너를 배포하는 데 필요한 오케스트레이션 및 관리 기능을 제공한다. 쿠버네티스 오케스트레이션을 사용하면 여러 컨테이너에 걸쳐 애플리케이션 서비스를 구축하고 클러스터 전체에서 컨테이너 일정을 계획하고 컨테이너를 확장하여 컨테이너의 상태를 지속적으로 관리할 수 있다. 

## 2. 쿠버네티스 주요 구성 요소: 클러스터 시스템

---

쿠버네티느 클러스터는 **명령을 내리는 컨트롤 플레인**과 **실제 업무를 수행하는 워커 노드**로 구성된다.

<img width="646" height="278" alt="image" src="https://github.com/user-attachments/assets/e99bb42b-9091-4ee3-b0da-4aab5c5e41e3" />


### (1) 클러스터

컨트롤 플레인 하나 이상의 컴퓨팅 머신 또는 노드로 구성된 클러스터는 최소 하나 이상의 제어판 컴포넌트와 이와 연결된 몇개의 워커 노드로 구성되어있다.

### (2) 컨트롤 플레인: 클러스터의 두뇌

쿠버네티스 노드를 제어하는 프로세스들이 모여있는 곳이다. 여기에서 모든 태스크의 할당이 시작되고 제어판 컴포넌트는 클러스터가 잘 작동할 수 있게 돕는다.

- **etcd**
    - 쿠버네티스 클러스터의 모든 데이터를 담고 있는 key-value 저장소이다.
    - 인프라를 원하는 상태로 만들기 위해 정상 상태에 대한 스냅샷 및 관리에 필요한 메타데이터를 저장한다
- **kube-api-server**
    - 쿠버네티스 클러스터의 허브로서 클라이언트와 etcd에 저장된 데이터 사이의 상호작용을 중개한다
    - 사용자, 클러스터 내 구성 요소, 그리고 외부 컴포넌트가 서로 통신할 수 있도록 HTTP API를 제공한다.
    - kube-api-server 작동 원리
        
        <img width="597" height="365" alt="image" src="https://github.com/user-attachments/assets/e7e7496d-396e-4e5f-88d3-f632e0cefd3a" />

        
- **kube-scheduler**
    - 새로운 POD를 감지하여 어떤 워커노드에 실행시킬지를 선택하는 역할을 한다
    - 노드의 현재 상태와 Pod의 요구사항을 체크하며, 노드에 라벨을 부여한다.
- **kube-conroller-manager**
    - API 서버를 통해 클러스터의 다양한 컴포넌트들의 상태를 감지하고, 원하는 상태로 만드는 역할을 한다.
    - 다양한 컨트롤러가 하나로 패키징되어 단일 프로세스 내에서 실행되게 한다.

### (3) 워커 노드: 실제 실행 환경

kubelet이라는 프로세스가 돌아가고 있는데, 이 kubelet은 다른 노드와 서로 통신하거나 컨테이너를 실행하는 등의 태스크를 실행할 수 있게 한다. 한 개 이상의 컨테이너가 자리잡고 있으며, 워커 노드는 실제로 애플리케이션이 실행되고 있는 곳이다.

- **kubelet**
    - 각 노드에서 실행되는 기본 노드 에이전트이다.
    - 컨테이너를 생성, 삭제하고 상태를 모니터링하며 마스터 노드와의 통신을 담당한다
    - kubelet이 작동하는 원리는 PodSpec 측면에서 작동하며, 파일로 명시된 PodSpec부분에 그 코드에 설명된 컨테이너가 실행되고 정상 작동하는 지를 확인한다.
    - kubelet은 쿠버네티스에서 생성되지 않은 컨테이너는 관리하지 않는다
- **kube-proxy**
    - 모든 워커 노드마다 실행되는 네트워크 프록시이다
    - 다른 POD간의 네트워크 통신과 클러스터 바깥에서 POD로 네트워크 통신을 할 수 있게 해준다
    - 성능 상의 이우로 별도의 프록시 프로그램 대신 iptable 또는 IPVS를 사용한다. (설정만 관리)
        
        <img width="546" height="380" alt="image" src="https://github.com/user-attachments/assets/ed244667-eebc-4a67-8c31-f724777c417c" />

        
- **Pod**
    - 단일 노드에 배포된 하나 이상의 컨테이너 그룹이다.
    - IP 주소, 호스트 이름 들을 공유하는 최소 배포 단위이다.
        
       <img width="519" height="263" alt="image" src="https://github.com/user-attachments/assets/04a70285-300b-4468-85b8-bdcbc47b6bf2" />

        

## 3. 정리 및 퀴즈

- **지휘자 (Control Plane)**
    - 악보(etcd)를 보고 각 연주자에게 언제 연주할지 지시(API Server/Scheduler)하며, 
    전체 화음이 깨지지 않게 관리(Controller)한다.
- **연주자 (Worker Node)**
    - 지휘자의 신호를 받아 실제로 악기를 연주(Container 실행)한다. 
    각 연주자 옆에는 악보를 확인하고 지휘자를 보는 매니저(Kubelet)가 있습니다.
- **악기 세트 (Pod)**
    - 연주자가 사용하는 악기 묶음이다. 
    한 사람이 북과 심벌즈를 같이 다루듯, 관련된 기능들을 하나로 묶어 관리합니다.

Q. 특정 노드가 다운되었을 때, 다른 노드에 다시 Pod를 띄우는 결정은 누가 하고, 실행은 누가 할까?
A: **결정은 Controller Manager와 Scheduler가** 하고, **실행은 새로운 노드의 Kubelet이** 담당한다.
