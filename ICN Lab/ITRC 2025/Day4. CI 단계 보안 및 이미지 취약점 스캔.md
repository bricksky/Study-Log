<aside>

어제 정리한 RBAC이 클러스터 '내부'의 문지기였다면, 
오늘 공부할 CI 단계 보안은 성벽을 쌓기 전 벽돌에 금이 갔는지 미리 검사하는 과정과 같다.

보안 사고를 막는 가장 효율적인 방법은 사고가 나기 전, 즉 배포 전(CI 단계)에 문제를 발견하는 것이다. 
'이미지 취약점 스캔'과 '결과물 보안'이 실제 파이프라인에서 어떻게 맞물리는지 정리해 보자

</aside>

</br>

## 1. Shift Left: 보안을 더 빠르게, 더 왼쪽으로

---

<img width="993" height="480" alt="image" src="https://github.com/user-attachments/assets/81856121-e70f-4265-8654-bc10e8b0509e" />


쿠버네티스와 같은 클라우드 네이티브 환경에서 보안의 핵심 철학은 'Shift Left’이다. 
여기서 '왼쪽'은 소프트웨어 개발 생명 주기(SDLC)의 앞 단계인 **코드 작성 및 빌드 단계**를 의미한다.
****


### 1.1 왜 '왼쪽'으로 가야 하는가? (비용과 위험의 상관관계)

전통적인 보안은 운영(오른쪽) 단계에서 방화벽을 세우거나 침입 탐지를 하는 방식이었다. 하지만 이 방식은 두 가지 치명적인 단점이 있다.

- **기하급수적인 수정 비용**
    - 운영 단계에서 발견된 보안 취약점을 수정하려면 서비스 중단, 코드 재검토, 재빌드, 재배포 과정을 거쳐야 하는데, 이는 빌드 단계에서 수정하는 것보다 최대 수십 배의 비용이 든다.
- **공격 표면의 방치**
    - 보안 검수가 늦어질수록 취약점이 포함된 이미지가 클러스터 내부에 쌓이게 되며, 이는 해커에게 공격의 발판을 미리 제공하는 꼴이된다.

</br>

### 1.2 보안을 '품질의 영역'으로 통합

Shift Left는 보안을 별도의 검수 단계가 아닌, 유닛 테스트와 같은 '코드 품질'의 일부로 만든다. 빌드 파이프라인(CI) 내에 보안 스캔을 배치함으로써, 개발자는 본인이 만든 결과물의 보안 상태를 즉각적으로 피드백받고 수정할 수 있게 된다.

</br></br></br>

## 2. CI Vulnerability Scan: 이미지 취약점 점검 프로세스

---

이미지가 빌드되는 즉시 수행되는 **CI Vulnerability Scan**은 "이미지에 금이 가 있는가?"를 검사하는 과정이다.

</br>

### 2.1 스캔의 3단계 레이어

1. **OS 패키지 스캔**
    - 이미지의 기반이 되는 베이스 이미지(Ubuntu, Centos, Alpine 등) 내에 포함된 패키지들의 CVE(공통 보안 취약점)를 검사.
2. **애플리케이션 의존성(SCA) 스캔**
    - 앱에서 사용하는 라이브러리(Spring Boot의 jar, Node.js의 npm 등)에 포함된 알려진 취약점을 분석
3. **Secrets/IaC 스캔**
    - 실수로 이미지 안에 포함된 API Key, 패스워드나 Dockerfile의 잘못된 설정(예: Root 권한 실행 등)을 찾아냄

쿠버네티스 생태계의 표준 도구인 Trivy를 활용하면 아래와 같은 **Fail-Fast** 정책을 구현할 수 있다.

- **Severity Threshold:** "Critical 등급 취약점이 하나라도 나오면 빌드 파이프라인을 중단(Exit 1)시킨다."
- **결과:** 보안 기준을 통과하지 못한 이미지는 절대로 저장소에 올라가거나 배포될 수 없다.

</br></br></br>

## 3. Artifact Security: 빌드 결과물의 무결성 보장

---

취약점 스캔을 통과한 이미지는 이제 안전하게 보관되어야 하는데, 이것을 Artifact Security라고 한다.

</br>

### 3.1 이미지 서명

스캔을 마친 깨끗한 이미지에 "이 이미지는 검증된 정품임"을 증명하는 디지털 도장을 찍는다

- **Cosign (Sigstore)**
    - 이미지가 빌드된 직후 고유한 개인키로 서명한다.
- **신뢰의 사슬**
    - 클러스터에서는 이 서명을 확인하여, 중간에 누군가 이미지를 가로채 취약점이 있는 코드를 심었거나 변조했는지를 즉시 감지한다.

</br>

### 3.2 Private Registry 보안 및 불변성

- **Access Control**
    - 이미지 저장소에 접근할 수 있는 권한을 최소화(RBAC)하여 허가된 CI 도구만 이미지를 Push 할 수 있게 한다.
- **Immutable Tags**
    - `latest` 태그 사용을 금지하고 고유한 해시값(Digest)을 사용하여, 한 번 배포된 아티팩트가 절대 다른 내용으로 교체되지 않도록 관리한다.

</br></br></br>

## 4. 배포 전 이미지 보안 점검 전체 흐름

---

최종적으로 우리가 구축해야 할 보안 프로세스는 다음과 같이 연결된다.

1. **[CI 시작]** 
    - 개발자가 코드를 푸시하고 빌드가 트리거됨.
2. **[Vulnerability Scan]** 
    - 빌드된 이미지에 대해 Trivy 스캔 수행.
        - 취약점 발견 시 → 즉시 중단 및 개발자 피드백.
        - 취약점 미발견 시 → 다음 단계 진행.
3. **[Artifact Security]** 
    - 안전한 이미지를 Private Registry로 푸시.
4. **[Signing]** 
    - 푸시된 이미지에 Cosign으로 디지털 서명 추가.
5. **[Registry Scan]** 
    - 저장소에 있는 동안에도 새로운 취약점이 발표되는지 주기적으로 재스캔 수행.

</br>

추가로 실무에선 아래와 같이 사용한다.

- **경량 이미지 사용**
    - 필요한 바이너리만 남기고 OS 패키지를 최소화하면 스캔할 대상이 줄어들고, 
    따라서 취약점 발견 확률도 획기적으로 낮아진다
- **멀티 스테이지 빌드**
    - 빌드 환경과 실행 환경을 분리하여 최종 아티팩트에는 소스 코드와 빌드 도구가 남지 않게 한다.
- **SBOM(Software Bill of Materials) 관리**
    - 이미지가 포함하고 있는 모든 소프트웨어 목록을 문서화하여, 새로운 취약점이 터졌을 때 우리 시스템이 영향받는지 즉시 파악하게 한다.
