### "사용자가 구독 버튼을 눌렀을 때, 우리 서버 내부에서는 어떤 일이 벌어질까?"
> 🔗 **관련 PR**: [구독 트랜잭션과 메일 발송 로직을 분리한다.](https://github.com/maeil-mail/maeil-mail-be/pull/299)

> 단순히 데이터를 저장하고 환영 메일을 보내는 과정처럼 보이지만, 그 이면에는 데이터베이스 커넥션이라는 귀한 자원이 얽혀 있다. 현재의 구독 로직은 비즈니스 로직과 외부 API 호출이 하나의 트랜잭션으로 묶여 있어, 메일 서버의 지연이 곧 전체 시스템의 장애로 이어질 수 있는 구조다. 이번 글에서는 시퀀스 다이어그램과 클래스 다이어그램을 통해 현재 구조의 위험성을 파헤치고, Spring Event와 비동기 처리를 도입해 시스템의 처리량을 극대화한 과정을 정리한다.
> 

</br>

**리팩토링 요약**

배경: 트랜잭션 범위 내 외부 API 호출로 인한 데이터베이스 커넥션 고갈 위기 파악

핵심: Spring Event 및 TransactionalEventListener를 통한 관심사 분리

결과: 데이터베이스 커넥션 점유 시간 단축 및 외부 시스템 장애 전파 차단

</br></br>

## 1. 문제 상황 분석: "DB 커넥션을 잡고 기다리는 3초"

현재 `SubscribeService`의 구독 메서드는 `@Transactional` 안에서 데이터베이스 저장과 메일 발송을 순차적으로 수행한다.

<img width="8192" height="4778" alt="image (4)" src="https://github.com/user-attachments/assets/6027be8e-e711-4513-b2c1-84a319c713a9" />


**데이터베이스 커넥션은?** 

서버와 데이터베이스가 대화하기 위해 미리 만들어둔 소중한 연결선이다. 이 코드는 데이터베이스 작업이 끝났음에도 불구하고, 메일 서버가 응답을 줄 때까지 약 3초 동안 비싼 커넥션을 놓아주지 않는다. 이는 시스템 전체의 회전율을 떨어뜨리는 치명적인 설계 결함이다.

</br>

### 비유: 맛집 식당의 테이블 회전율

이 상황을 식당의 운영 방식에 비유하면 왜 비효율적인지 명확해진다. 식당에는 손님을 받을 수 있는 테이블이 딱 10개뿐이라고 가정하자.

**❌ AS-IS (현재 상황):**

손님이 식사를 0.1초 만에 마쳤다. 그런데 테이블에 그대로 앉은 채로 "친구에게 전화 한 통만 하고 나갈게요"라며 3초 동안 통화를 한다. 밖에는 배고픈 대기 손님들이 가득한데, 식사가 끝난 손님이 전화를 하느라 테이블을 비워주지 않아 식당 입구는 아수라장이 된다. 이것이 바로 커넥션 풀 고갈로 인한 서버 장애의 모습이다.

**✅ TO-BE (개선 후):**

손님이 식사를 마치자마자 종업원이 안내한다. "손님, 통화는 나가서 로비 소파에서 편하게 하시겠어요?" 손님은 즉시 테이블을 비우고 로비로 이동한다. 테이블은 0.1초 만에 비워졌고, 대기하던 다음 손님이 즉시 들어와 식사를 시작한다. 식당의 처리량은 비약적으로 상승한다.

</br>

### 기술적 해결: Spring Event와 Async 적용

<img width="9856" height="2851" alt="Group 34208" src="https://github.com/user-attachments/assets/ef3192aa-d890-462a-94e1-9289c4b3cfbc" />


이 문제를 해결하기 위해 **Spring Event**를 사용하여 두 관심사를 분리한다.

1. **Service**: 구독 저장이 끝나면 "구독 완료 이벤트"만 던지고 트랜잭션을 끝낸다.
2. **EventListener**: 이벤트를 받아서 별도의 스레드(`@Async`)에서 메일을 보낸다. 이때는 트랜잭션이 이미 커밋된 후(`AFTER_COMMIT`)

메일 발송은 데이터베이스의 원자성이 필요 없는 작업이다. 따라서 이를 별도의 작업 단위로 분리하여 로비로 내보내는 과정이 필요하다.

</br>

**Step 1. 구독 완료 이벤트 정의**

구독이 성공했다는 사실을 담을 가벼운 객체를 생성한다.


**Step 2. 이벤트 리스너를 통한 관심사 격리**

기존 서비스에 있던 메일 발송 로직을 리스너로 옮긴다. 
여기서 핵심은 `@Async`와 `TransactionPhase.AFTER_COMMIT`이다.


**Step 3. 서비스 로직의 경량화**

이제 서비스는 메일 발송기를 직접 의존하지 않고, 단지 이벤트만 발행한 뒤 즉시 트랜잭션을 종료한다.


</br>

### 구조적 변화와 기대 효과

<img width="9856" height="2851" alt="Group 34208" src="https://github.com/user-attachments/assets/65ad9085-f6ad-4e16-a0a6-3f89b1ebfaaf" />


**4.1 높은 결합도의 해소**

기존의 SubscribeService는 리포지토리뿐만 아니라 메일 전송기, 뷰 렌더러까지 직접 의존하고 있었다. 이는 단일 책임 원칙에 어긋날 뿐만 아니라 테스트를 어렵게 만드는 요인이었다. 리팩토링 후에는 메일 발송 로직이 리스너로 이관되면서 서비스는 오직 구독 저장이라는 본질적인 역할에만 집중하게 되었다.

**4.2 데이터 흐름의 최적화**

데이터 흐름도 관점에서 보면, 과거에는 트랜잭션이라는 감옥 안에 메일 발송이라는 무거운 짐이 갇혀 있었다. 이제는 트랜잭션 범위가 데이터베이스 작업으로 한정되어 박스가 매우 작아졌다. 외부 통신(SMTP)이 아무리 지연되더라도 데이터베이스는 이미 작업을 마치고 커넥션을 반납했으므로, 시스템의 안정성은 비약적으로 향상된다.


</br></br>

## 2. 코드의 조립 구조 : 클래스 다이어그램

먼저 "누가 누구를 필드(멤버 변수)로 가지고 있는가?"를 나타낸 클래스 다이어그램을 통해, 현재 `SubscribeService`가 안고 있는 **높은 결합도(High Coupling)** 문제를 확인한다.

<img width="4277" height="2340" alt="image (4)" src="https://github.com/user-attachments/assets/cd2566e2-3c8b-41dc-adde-d44899307d9d" />

</br>

### 1) 구조 분석

**주인공 (SubscribeService):** 이 클래스는 현재 아래 4개의 객체를 주입받아 사용한다.

- `SubscribeRepository` (DB)
- `VerifySubscribeService` (검증)
- `SubscribeWelcomeView` (화면/HTML) ❌
- `MailSender` (메일 발송) ❌

**화살표의 의미 (->):** 화살표는 **"의존한다(Depends on)"**는 것을 의미한다. 
즉, `SubscribeService` 코드를 열었을 때, `private final MailSender mailSender;`와 같이 다른 클래스의 이름이 명시되어 있음을 뜻한다.

</br>

### 2) 빨간색 X 표시의 의미

다이어그램 하단에 표시된 **"❌ Direct Dependency"**가 이번 리팩터링의 핵심 타겟이다.

- **문제점 1: 관심사의 혼재 (SRP 위반)**
    - **구독 서비스의 본질:** "사용자의 구독 요청을 받아서 DB에 저장하는 것"이다.
    - **현재 코드:** "저장도 하고, HTML 파일도 읽고(View), 외부 메일 서버와 통신도 수행(Sender)"한다.
    - **결과:** 메일 템플릿만 변경하려 해도 `SubscribeService`를 수정해야 한다. 코드가 비대해지고 관리가 어려워진다.
- **문제점 2: 강한 결합 (Tight Coupling)**
    - `SubscribeService`가 `MailSender`를 직접 참조한다. 이로 인해 DB 트랜잭션 내에서 메일 서버 통신이 강제로 수행되는 구조가 형성된다.

</br>

### 3)  리팩터링 후 예상도

<img width="6671" height="2025" alt="image (5)" src="https://github.com/user-attachments/assets/94769444-6424-4d30-b650-ac5157e624c0" />


- *이벤트(Event)**를 도입하면 구조는 다음과 같이 변화한다.
1. `SubscribeService`에서 `SubscribeWelcomeView`와 `MailSender`를 향한 화살표가 제거된다. ✂️
2. 대신 `EventPublisher`라는 가벼운 객체 하나에만 의존하게 된다.
3. 제거된 두 객체(View, Sender)는 새로 생성된 `SubscribeEventListener`로 이동한다.

결론적으로, `SubscribeService`는 메일 발송 방식이나 HTML 구조를 전혀 알지 못하는 **"순수한 구독 담당자"**로 재탄생한다. 

---

</br></br>

## 3. 하나의 요청이 처리되는 논리적인 범위 : 데이터 흐름도

<img width="3213" height="3610" alt="image (4)" src="https://github.com/user-attachments/assets/d3c6add0-e2f9-4f35-9a0e-704d4bd180ec" />


앞서 클래스 다이어그램이 "코드의 조립 구조"를 보여주었다면, 데이터 흐름도는 **"하나의 요청이 유입되어 처리되는 논리적인 범위(Scope)"**를 시각화한다.

</br>

### 그림 해석 

이 그림은 **"구독 요청 하나가 처리될 때, DB 트랜잭션이라는 감옥 안에 어떤 작업들이 갇혀 있는지"**를 보여준다. 특히 가장 중요한 부분은 붉은색 박스로 표시된 **Transaction (트랜잭션 범위)**이다.

**1. 입력 (Request -> Service)**

- **코드:** `public void subscribe(SubscribeRequest request)`
- 사용자가 "구독할래요!" 버튼을 누르면 `SubscribeRequest` 데이터가 서비스로 유입된다.

**2. 트랜잭션 박스 (Transaction Scope)**

- **코드:** `@Transactional`
- **의미:** 이 박스 내의 작업들은 **"운명 공동체"**다. 하나라도 실패하면 전체가 롤백되며, 모든 작업이 종료될 때까지 DB 연결을 점유한다.

**3. DB 작업 구간 (Verify -> Entity -> DB)**

- **흐름:** 이메일 검증 → 객체 생성 → `repository.save()`
- **특징:** 빠르고 필수적인 작업이다.

**4. 위험한 동거 (View -> MailMsg -> Sender)**

- **흐름:** HTML 렌더링(View) → 메일 객체 생성(MailMsg) → 메일 발송기 전달(Sender).
- **문제점:** 무거운 작업들이 트랜잭션 내부에 존재한다. 즉, **"메일을 준비하고 보내는 동안 DB 문을 잠그고 있는"** 상황이다.

**5. 외부 통신 (Sender -> SMTP)**

- **설명:** `MailSender`가 외부 SMTP 서버로 메일을 전송하는 과정이다.
- **영향:** 내부의 Sender가 외부 응답을 기다려야 하므로, 결과적으로 Transaction 박스 전체가 외부 통신 속도에 종속된다.

---

</br>

### 해결: Spring Event와 Async 적용

<img width="2260" height="3915" alt="image (4)" src="https://github.com/user-attachments/assets/c3d37d88-42aa-48a0-a9db-acd740fefac1" />


문제를 해결하기 위해 Spring Event를 사용하여 두 관심사를 분리한다.

- **Service:** 구독 저장이 끝나면 "구독 완료 이벤트"만 발행하고 트랜잭션을 즉시 종료한다. (Transaction 박스 탈출!)
- **EventListener:** 이벤트를 받아 별도 스레드(`@Async`)에서 메일 발송을 수행한다.

</br>

### **리팩터링 후의 변화**

리팩터링을 적용하면 데이터 흐름도는 극적으로 변화한다.

1. **Transaction 박스**는 DB 작업만 수행하도록 축소된다.
2. **AsyncJob (별도 작업) 박스**가 새롭게 생성된다.
3. 이제 SMTP 지연이 발생하더라도, DB 트랜잭션은 이미 커밋되었으므로 시스템에 영향을 주지 않는다.

</br></br>

## 4. 마무리 및 회고

이번 글에서는 '메일 발송'이라는 외부 작업이 DB 트랜잭션을 붙잡고 있을 때 발생하는 문제점을 분석하고, 이를 Spring Event와 비동기(`@Async`) 처리로 해결하는 과정을 설계했다.

솔직히, 이 과정을 겪기 전까지는 '데이터베이스 커넥션 풀'이라는 개념조차 생소했다. 서버와 DB가 연결을 맺는 과정이 얼마나 비싼 비용을 치르는지, 그리고 그 개수가 한정되어 있다는 사실을 전혀 알지 못했다. 하지만 이번 설계를 통해 커넥션은 무한한 자원이 아니며, 단 0.1초라도 낭비해서는 안 되는 시스템의 생명선임을 비로소 깨닫게 되었다.

가장 흥미로웠던 점은, 학교 **네트워크 수업 시간**에 배웠던 **SMTP** 프로토콜이나 **TCP 3-Way Handshake** 개념을 실제 문제 해결 과정에서 발견했다. 이론으로만 배우던 "연결 설정의 비용"이, 실제 시스템에서는 "사용자의 대기 시간"이자 "DB 커넥션 고갈의 원인"이 될 수 있음을 확인했다. 

또한 **시퀀스 다이어그램, 클래스 다이어그램, 데이터 흐름도**를 직접 그려보며 코드의 구조를 시각화하는 것이 얼마나 강력한 무기인지 알게 되었다. 줄글로 코드를 읽을 때는 보이지 않던 병목 구간과 복잡한 의존성 문제가, 그림을 그리는 순간 명확하게 드러났다. 앞으로도 복잡한 문제를 마주할 때마다 이 도구들을 적극 활용할 생각이다.
