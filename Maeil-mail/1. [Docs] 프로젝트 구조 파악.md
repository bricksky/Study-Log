<aside>

</aside>

```java
매일메일 프로젝트에 서버 개발자로 합류하게 되었습니다. 아직 정식 온보딩 전이지만, 
레포지토리를 클론 받아 프로젝트 구조를 먼저 파악하고 있습니다. 기존에 경험했던 프로젝트보다 규모가 크고, 
새로운 동료들과 함께하는 환경이라 긴장도 되지만 그만큼 잘해내고 싶은 마음이 큽니다. 
낯선 코드와 마주하며 생기는 궁금증들을 하나씩 해결해가는 과정, 그리고 고민한 흔적들을 이곳에 꼼꼼히 기록해두려 합니다.
```

</br>

## 1. `MaeilMailApplication.java`의 역할: "관제탑이자 시동 버튼"

```java
package maeilmail;

@EnableScheduling
@ConfigurationPropertiesScan(basePackages = {MAEIL_MAIL, MAEIL_WIKI})
@SpringBootApplication(
        scanBasePackages = {MAEIL_MAIL, MAEIL_WIKI},
        exclude = HibernateJpaAutoConfiguration.class
)
public class MaeilMailApplication {

    public static void main(String[] args) {
        SpringApplication.run(MaeilMailApplication.class, args);
    }
}
```

어떤 순서로 코드가 동작되는지 확인하고자 시작점에 해당하는 파일을 찾게되었다. 
main 메서드의 `SpringApplication.run(...)`이 실행되면서 내장 톰캣(Tomcat)이 켜지고 웹 서버가 작동한다. 단순히 켜지는것 뿐만 아니라, 어떤 부품을 로딩할지, 어떤 기능을 끄고시작할지 정하는 부분이다.

### (1) `exclude = HibernateJpaAutoConfiguration.class`

- **자동 주행 끄고, 수동 조작하겠습니다.**

원래 스프링 부트는 자체적으로 DB설정을 해주지만, 우리 프로젝트에서는 강제로 끈 것이다.

프로젝트에서는 **쿼리 DSL**도 사용해야하고, 추후 DB가 여러개로 나뉠 수 있기 때문에 이 설정을 세팅한것 같다.

스프링이 해주는 기본 설정은 부족해서, 우리가 직접 만든 DB 파일을 쓰겠다!! 라는 의미로 생각하면 될듯 하다.

**+  쿼리 DSL이 뭘까?**

---

보통 DB에 데이터를 요청할 때 SQL을 사용한다. `"SELECT * FROM user WHERE name = 'kim'”`

하지만, 우리 프로젝트에서는 QuaryDSL을 사용하는데, 이건 SQL을 문자가 아닌 자바 코드로 작성하게 해주는 기술이다.

- 왜 쓸까?
    - 오타를 방지해준다. → 문자열은 오타가 나면 실행을 해봐야 알지만, QuaryDSL은 코드를 짤 때 바로 오류를 찾아준다
    - 복잡한 쿼리를 해결해준다. → 조건이 많거나 동적인 검색(필터링)을 구현할 때 압도적으로 편리하다.

<aside>

`mail-app/src/main/java/maeilmail/config/QueryDslJpaConfig.java` 파일에서 
이 QuaryDSL을 사용하기 위한 설정(JPAQueryFactory)을 등록하다고 한다.

</aside>

### (2) `scanBasePackages = {MAEIL_MAIL, MAEIL_WIKI},`

- **흩어진 부품들(Mail, Wiki) 다 모여!**

지금 `MaeilMailApplication.java` 파일은 mail-app 모듈에 있다. 하지만 실제 비즈니스 로직은 `main-core`, `wiki-core` 같은 다른 모듈에 숨어있다. 따라서 해당 코드가 없다면, 스프링은 `mail-app` 내부만 돌다가, 서비스가 없다고 인식해서 어떤 기능도 동작하지 못하게 된다.

따라서 그런 상황을 방지하고자 `MAEIL_MAIL`, `MAEIL_WIKI` 라고 찝어서 말해주는 것이다. 이 덕분에 물리적으로 나뉜 모듈들이 실행될 때 하나로 합쳐지는 것.

**+ 지정해주지 않으면 어떻게 될까?**

---

위키 기능이 전부 동작하지 않는다.

스프링부트는 기본적으로 `MaeilMailApplication`파일이 위치한 패키지와 그 하위 패키지만 뒤져서 빈을 등록한다

현재 `MaeilMailApplication`은 `maielmail` 패키지 안에 있지만, 위키 관련 코드는 `maeilWiki` 라는 완전히 다른 패키지 이름으로 시작한다. 스캔 범위를 지정하지 않으면 무시하고 지나간다ㅜㅜ

**+ `{MAEIL_MAIL, MAEIL_WIKI}`와 `Application`의 관계**

---

이 설정은 내 집인 maeilmail 뿐만 아니라, 옆집인 maeilwiki 도 전부 우리의 가족으로 생각하고 데려오라는 뜻

### (3) `@EnableScheduling`

- "알람 시계 켜기”

우리 서비스는 매일 오전 7시가 되면 메일을 발송해준다, 따라서 시간이 되면 자동으로 돌아가야 하기때문에, 해당 어노테이션을 사용한 것이다. 

## 2. **`SubscribeApi.java`의 역할: "주문을 접수하는 키오스크"**

```java
package maeilmail.api;

@RestController
@RequiredArgsConstructor
class SubscribeApi {

    private final SubscribeService subscribeService;
    private final UnsubscribeService unsubscribeService;
    private final TransmissionFrequencyService transmissionFrequencyService;

    @PostMapping("/subscribe/verify/send")
    public ResponseEntity<Void> send(@RequestBody VerifyEmailRequest request) {
        subscribeService.sendCodeIncludedMail(request);

        return ResponseEntity.noContent().build();
    }

    @PostMapping("/subscribe")
    public ResponseEntity<Void> subscribe(@RequestBody SubscribeRequest request) {
        subscribeService.subscribe(request);

        return ResponseEntity.noContent().build();
    }

    @DeleteMapping("/subscribe")
    public ResponseEntity<Void> unsubscribe(@RequestBody UnsubscribeRequest request) {
        unsubscribeService.unsubscribe(request);

        return ResponseEntity.noContent().build();
    }

    @PatchMapping("/subscribe/email-frequency")
    public ResponseEntity<Void> changeFrequency(@RequestBody TransmissionFrequencyRequest request) {
        transmissionFrequencyService.changeFrequency(request);

        return ResponseEntity.noContent().build();
    }

    @GetMapping("/subscribe/email-frequency")
    public ResponseEntity<TransmissionFrequencyResponse> getFrequency(@RequestParam String email) {
        TransmissionFrequencyResponse response = transmissionFrequencyService.getFrequency(email);

        return ResponseEntity.ok(response);
    }
}

```

구독해주세요! 라는 사용자의 요청을 받아서, 내용물(이메일 주소)이 멀쩡한지만 확인하고 실제 일은 Service에게 토스하는 단순한 기능을 담당하는 부분이다.

### (1) `@RestController` & `@RequiredArgsConstructor`

**여기는 웹 요청 받는 창구입니다.**

- `@RestController`
    - 이 클래스가 스프링부트에게 “저는 웹 요청 처리하는 담당입니다!” 라고 명찰을 다는 것이다.
    해당 어노테이션이 있어야 외부에서 접속 가능하다.
- `@RequiredArgsConstructor`
    - 롬복의 기능으로, 생성자를 대신 만들어주는 역할이다.

### (2) `@PostMapping("/subscribes")`

**구독 신청 버튼은 여기입니다.**

- 주소가 `/subscribes`이고, 방식이 `POST`(데이터 전송)인 요청이 들어오면 딱 이 메서드(`subscribe`)가 실행된다.

### (3) `@RequestBody @Valid SubscribeRequest request`

**신청서 내용물 확인하겠습니다.**

```java
@PostMapping("/subscribe")
    public ResponseEntity<Void> subscribe(**@RequestBody** **SubscribeRequest** request) {
        subscribeService.subscribe(request);

        return ResponseEntity.noContent().build();
    }
```

- `@RequestBody`
    - 인터넷 선을 타고 들어온 **JSON 데이터**(`{"email": "test@naver.com", ...}`)를 자바 객체(`SubscribeRequest`)로 변환해 준다.
- `@Valid`
    - 잠깐! 빈 칸은 없는지, 이메일 형식이 맞는지 검사 좀 할게요.
    - 코드가 실행되기 전에 입력값이 올바른지 검문 검색을 수행한다. 만약 이메일 주소에 `@`가 없다면 여기서 바로 에러 발생
- `SubscribeRequest`
    - 사용자가 보낸 데이터를 담는 그릇(DTO)이다.

### (4) `subscribeService.subscribe(request)`

**주방장님, 여기 주문 들어왔어요!**

```java
@PostMapping("/subscribe")
    public ResponseEntity<Void> subscribe(@RequestBody SubscribeRequest request) {
        **subscribeService.subscribe(request);**

        return ResponseEntity.noContent().build();
    }
```

- 컨트롤러(Api)는 직접 요리(비즈니스 로직)를 하지 않습니다.
- 주문서(`request`)를 들고 **전문가인 서비스(`subscribeService`)**에게 그대로 전달만 합니다.
- 이 부분이 바로 **Layered Architecture(계층형 구조)**의 핵심입니다. 역할 분담이 확실하죠.

## 3. 비즈니스 로직의 심장 (서비스 & 도메인)

### Step 3-1. SubscribeService.java

```java
package maeilmail.subscribe.command.application;

@Slf4j
@Service
@RequiredArgsConstructor
public class SubscribeService {

    private final SubscribeRepository subscribeRepository;
    private final VerifySubscribeService verifySubscribeService;
    private final SubscribeWelcomeView welcomeView;
    private final MailSender mailSender;

    @Transactional
    public void subscribe(SubscribeRequest request) {
        log.info("이메일 구독 요청, 이메일 = {}", request.email());
        trySubscribe(request);
        sendSubscribeWelcomeMail(request.email());
        log.info("이메일 구독 성공, 이메일 = {}", request.email());
    }

    private void trySubscribe(SubscribeRequest request) {
        verifySubscribeService.verify(request.email(), request.code());
        List<Subscribe> subscribes = subscribeRepository.findAllByEmailAndDeletedAtIsNull(request.email());
        List<QuestionCategory> newSubscribeCategories = findNewSubscribeCategories(request, subscribes);
        if (newSubscribeCategories.isEmpty()) {
            return;
        }

        newSubscribeCategories.forEach(it -> subscribe(it, request));
        synchronizeFrequency(request, subscribes);
    }

    private List<QuestionCategory> findNewSubscribeCategories(SubscribeRequest request, List<Subscribe> subscribes) {
        return request.category().stream()
                .map(QuestionCategory::from)
                .filter(it -> isNotSubscribed(it, subscribes))
                .toList();
    }

    private boolean isNotSubscribed(QuestionCategory category, List<Subscribe> subscribes) {
        return subscribes.stream()
                .noneMatch(it -> it.getCategory() == category);
    }

    private void subscribe(QuestionCategory category, SubscribeRequest request) {
        SubscribeFrequency frequency = SubscribeFrequency.from(request.frequency());
        Subscribe subscribe = new Subscribe(request.email(), category, frequency);
        subscribeRepository.save(subscribe);
    }

    private void synchronizeFrequency(SubscribeRequest request, List<Subscribe> subscribes) {
        SubscribeFrequency frequency = SubscribeFrequency.from(request.frequency());
        subscribes.forEach(it -> it.changeFrequency(frequency));
    }

    public void sendCodeIncludedMail(VerifyEmailRequest request) {
        verifySubscribeService.sendCodeIncludedMail(request);
    }

    private void sendSubscribeWelcomeMail(String email) {
        String subject = "앞으로 면접 질문을 보내드릴게요.";
        String text = createText();
        MailMessage mailMessage = new MailMessage(email, subject, text, welcomeView.getType());
        mailSender.sendMail(mailMessage);
    }

    private String createText() {
        Map<Object, Object> attribute = new HashMap<>();

        return welcomeView.render(attribute);
    }
}

```

### (1) `@Transactional`

**"이 주문은 코스 요리입니다. 하나라도 망치면 전부 취소!"**

```java
 @Transactional
    public void subscribe(SubscribeRequest request) {
        log.info("이메일 구독 요청, 이메일 = {}", request.email());
        trySubscribe(request);
        sendSubscribeWelcomeMail(request.email());
        log.info("이메일 구독 성공, 이메일 = {}", request.email());
    }
```

- 메서드 위에 붙은 이 태그는 "원자성(Atomicity)"을 보장한다.
- 구독 검증, 저장, 이메일 발송 등 여러 단계가 있는데, 중간에 에러가 터지면 모든 DB 작업을 없던 일로 되돌림

### (2) `trySubscribe(request)`

```java
 private void trySubscribe(SubscribeRequest request) {
        verifySubscribeService.verify(request.email(), request.code());
        List<Subscribe> subscribes = subscribeRepository.findAllByEmailAndDeletedAtIsNull(request.email());
        List<QuestionCategory> newSubscribeCategories = findNewSubscribeCategories(request, subscribes);
        if (newSubscribeCategories.isEmpty()) {
            return;
        }

        newSubscribeCategories.forEach(it -> subscribe(it, request));
        synchronizeFrequency(request, subscribes);
    }
```

코드를 보면 `trySubscribe` 안에서 4단계의 로직이 실행된다.

1. **신원 확인 (`verifySubscribeService.verify`)**
    - "이메일 인증 번호 맞나요?" → 인증 코드가 틀리면 여기서 바로 에러를 뱉고 쫓아냄.
2. **중복 제거 (`findNewSubscribeCategories`)**
    - 사용자가 이미 '백엔드'를 구독 중인데 또 '백엔드'를 신청했을 수 있다.
    - `isNotSubscribed` 메서드를 통해 "아직 구독하지 않은 카테고리"만 골라냄
3. **구독 계약 체결 (`subscribe` -> `repository.save`)**
    - 걸러진 카테고리에 대해 진짜 `Subscribe` 객체를 만들고 DB에 저장

### (3) `sendSubscribeWelcomeMail`

```java
private void sendSubscribeWelcomeMail(String email) {
        String subject = "앞으로 면접 질문을 보내드릴게요.";
        String text = createText();
        MailMessage mailMessage = new MailMessage(email, subject, text, welcomeView.getType());
        mailSender.sendMail(mailMessage);
    }
```

**요리 다 나왔으니 서빙하세요.**

- 모든 DB 저장이 끝나면 축하 메일을 보냄

### Step 3-2. Subscribe.java

Entity를 단순히 "데이터 담는 그릇(DB 테이블)"으로만 생각하지만, 우리 프로젝트는 "도메인 주도 설계(DDD)" 사상이 들어가 있어서, Entity가 스스로 비즈니스 로직을 처리한다.

### (1) `subscribe` 테이블과 1:1 매핑

```java
@Entity
@Getter
@Table(name = "subscribe")
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Subscribe extends BaseEntity {
```

- DB의 `subscribe` 테이블의 한 행(Row)이 이 객체 하나가 된다.
- `BaseEntity`를 상속받았는데, 여기에 `createdAt`(생성일), `updatedAt`(수정일) 같은 공통 필드가 있다.
    
    ```java
    package maeilmail;
    
    @Getter
    @MappedSuperclass
    @EntityListeners(AuditingEntityListener.class)
    public abstract class BaseEntity {
    
        @CreatedDate
        @Column(updatable = false)
        private LocalDateTime createdAt;
    
        @LastModifiedDate
        private LocalDateTime updatedAt;
    }
    
    ```
    

### (2) 생성자 로직 (`determineSequenceByCategory`)

**"백엔드 구독자는 15번부터 시작한다?"**

```java
private long determineSequenceByCategory(QuestionCategory category) {
    if (category == QuestionCategory.BACKEND) {
        return 15L; 
    }
    return 0L;
}
```

- 생성자 안을 보니 재미있는 규칙이 있다. 백엔드(`BACKEND`) 카테고리를 선택하면 문제 번호(`nextQuestionSequence`)가 0번이 아니라 **15번**부터 시작하는데, 이건 물어봐야 알것 같다..
- 이런 비즈니스 규칙이 Entity 안에 숨어있는 것이 특징이다.

### (3) `unsubscribe()`

**"찢어버리지 말고, '취소됨' 도장만 찍으세요."**

```java
public void unsubscribe() {
    if (deletedAt != null) {
        throw new IllegalStateException("이미 구독이 취소되었습니다."); // 방어 로직
    }
    this.deletedAt = LocalDateTime.now(); // 데이터 삭제 대신 날짜만 기록
}
```

- `repository.delete()`를 호출해서 DB에서 아예 지워버리는 게 아니고,
- `deletedAt` 필드에 현재 시간을 넣어서 "이 사람은 취소한 사람임"이라고 표시만 남겨두는 것
- 실무에서 아주 많이 쓰는 패턴이라고 하는데,,, 처음 봤다
