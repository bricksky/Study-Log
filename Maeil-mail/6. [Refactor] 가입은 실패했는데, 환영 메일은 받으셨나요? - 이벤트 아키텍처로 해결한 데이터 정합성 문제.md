### "분명 비동기 처리인데, 왜 데이터 정합성이 깨질까?"
> 🔗 **관련 PR**: [구독 트랜잭션과 메일 발송 로직을 분리한다.](https://github.com/maeil-mail/maeil-mail-be/pull/299)
> 
> 

> "혹시 메일 발송은 비동기 스레드에서 처리해서, 구독 트랜잭션 범위 밖에서 수행되는 걸로 기억하는데 아니었을까요?”
> 처음 코드를 접했을 때, 단순히 구독 신청 트랜잭션과 메일 발송 로직이 얽혀 발생하는 문제라고 짐작했다. 하지만 하늘님의 이 질문을 듣고 코드를 다시 분석한 결과, 이미 `@Async`를 통해 메일 발송이 비동기적으로 처리되고 있음을 확인했다.
> 
> 진짜 문제는 기술적인 비동기 적용 여부가 아니라, **호출되는 시점** 그 자체였다. 데이터베이스 트랜잭션이 최종 커밋되기도 전에 메일 발송 스레드가 실행되면서, 롤백이 발생해도 메일은 이미 발송되어 버리는 논리적 모순이 존재했다.
> 
> 이 글에서는 하늘님의 도움으로 발견한 이 문제를 스프링의 이벤트 발행 메커니즘과 트랜잭션 훅(`@TransactionalEventListener`)을 도입하여 해결한 과정을 정리한다. 서비스의 책임을 명확히 분리하고, 비즈니스 로직과 부가 기능의 생명주기를 동기화함으로써 시스템의 신뢰성과 확장성을 확보한 기록이다.
> 

</br>

**리팩토링 요약**

- **배경:** 비동기 메일 발송과 트랜잭션 커밋 시점의 불일치로 인한 데이터 정합성 문제.
- **핵심:** `ApplicationEventPublisher`와 `@TransactionalEventListener(phase = AFTER_COMMIT)`를 활용한 이벤트 기반 아키텍처로 전환.
- **결과:** 데이터 정합성 보장, 서비스와 인프라 계층 간의 결합도 해소, 단일 책임 원칙 준수 및 유연한 확장성 확보.

---

</br>

### **1. 무엇이 문제였나: 가짜 구독자 발생 시나리오**

가장 심각한 문제는 데이터베이스 트랜잭션이 롤백되더라도 메일은 이미 발송되는 상황이었다. 아래는 당시의 문제 코드로, `SubscribeService`가 `MailSender`에 직접 의존하며 트랜잭션 내에서 메일 발송을 호출하고 있다.

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class SubscribeService {
    private final SubscribeRepository subscribeRepository;
    private final VerifySubscribeService verifySubscribeService;
    private final MailSender mailSender; // MailSender에 직접 의존
    private final SubscribeWelcomeView welcomeView;

		@Transactional
    public void subscribe(SubscribeRequest request) {
        log.info("이메일 구독 요청, 이메일 = {}", request.email());
        trySubscribe(request);  // DB 저장 로직
        sendSubscribeWelcomeMail(request.email());
        log.info("이메일 구독 성공, 이메일 = {}", request.email());
    }
    
    // 트랜잭션 커밋과 상관없이 메일 발송을 즉시 호출
    private void sendSubscribeWelcomeMail(String email) {
        String subject = "앞으로 면접 질문을 보내드릴게요.";
        String text = createText();
        MailMessage mailMessage = new MailMessage(email, subject, text, welcomeView.getType());
        mailSender.sendMail(mailMessage);
    }
}

```
<img width="1049" height="385" alt="image" src="https://github.com/user-attachments/assets/3ed340f1-e8c8-4a8c-98c0-7339cdc570f0" />


이 구조로 인해 시스템의 실제 데이터 상태와 사용자가 받는 피드백이 어긋나는 '가짜 구독' 상태가 발생했다.

</br>

**유령 구독자 발생 과정:**

1. **API 호출:** 사용자가 구독 신청 API를 호출한다.
2. **트랜잭션 시작:** `subscribe` 트랜잭션이 시작되고, 데이터베이스에 구독 정보를 저장한다. (아직 커밋되지 않은 상태)
3. **비동기 호출:** `@Async`로 구현된 `sendMail` 메서드가 호출되어 **즉시** 별도 스레드에서 메일 발송을 완료한다.
4. **예외 발생:** 트랜잭션 종료 직전, 예기치 못한 예외(DB 제약조건 위반 등)가 발생한다.
5. **롤백:** 트랜잭션이 롤백되어 데이터베이스에 구독 정보가 남지 않게 된다.
6. **모순된 경험:** 사용자는 '구독 실패' 응답을 받지만, 이미 '가입 환영' 메일을 수신한 상태가 된다.

이 현상의 근본 원인은 비즈니스 서비스(`SubscribeService`)가 메일 발송(`MailSender`)이라는 인프라 계층의 구체적인 행위를 직접 호출하는 **강한 결합** 구조에 있었다. 이는 구독 처리라는 핵심 책임에 알림 발송이라는 부가 기능이 섞여 **단일 책임 원칙**을 위배하고, 시스템의 복잡도를 높이는 결과를 낳았다.

---

</br>

### **2. 해결책: "서비스는 이벤트를 던지고, 리스너는 귀를 기울인다"**

문제의 실마리는 하늘님이 던져준 또 다른 힌트에서 찾을 수 있었다.

> "제가 얼핏 기억하기론 트랜잭션 훅(Hook) 메서드가 존재하는 걸로 알고 있어요."
> 

이 조언을 바탕으로 스프링이 제공하는 트랜잭션 이벤트 리스너, `@TransactionalEventListener`를 도입했다. 이 도구는 트랜잭션의 상태(Commit, Rollback 등)에 따라 특정 로직을 실행시킬 수 있는 강력한 '훅'을 제공하여 문제를 완벽하게 해결할 수 있었다.

<img width="1820" height="481" alt="image" src="https://github.com/user-attachments/assets/d81c7210-9177-4eb3-9e10-ea8820582e45" />


</br>

**Step 1: 서비스의 다이어트 - "구독만 처리하고 이벤트는 던져라"**

리팩토링의 첫 단계로, `SubscribeService`에서 메일 관련 의존성을 모두 제거했다. 이제 서비스는 자신의 핵심 책임인 구독 정보 저장에만 집중하고, 작업이 성공적으로 완료되었다는 사실을 '이벤트'로 발행하기만 한다.

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class SubscribeService {
    private final SubscribeRepository subscribeRepository;
    private final VerifySubscribeService verifySubscribeService;
    private final ApplicationEventPublisher eventPublisher; // 이벤트 발행자 주입

    @Transactional
    public void subscribe(SubscribeRequest request) {
        log.info("이메일 구독 요청, 이메일 = {}", request.email());
        trySubscribe(request);

        // 직접 호출 대신 "구독이 생성되었다"는 비즈니스 이벤트를 발행
        eventPublisher.publishEvent(new SubscribeCreatedEvent(request.email()));
        log.info("이메일 구독 성공, 이메일 = {}", request.email());
    }
    // ... 이하 생략
}

```

이제 `SubscribeService`는 메일 발송이 실패하든, 나중에 카카오톡 알림으로 수단이 바뀌든 관여하지 않는다. 오직 구독 로직의 성공 여부에만 집중하며 단일 책임을 명확히 지킨다.

</br>

**Step 2: 똑똑한 관찰자 - 트랜잭션 커밋 후 동작하는 리스너**

다음으로, 발행된 이벤트를 받아 처리할 `SubscribeEventListener`를 구현했다. 이 리스너에는 두 가지 핵심 장치가 숨어 있다.

- `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`: 트랜잭션이 데이터베이스에 **확실히 커밋된 직후에만** `sendWelcomeMail` 메서드를 실행한다. 이로써 '유령 구독자' 문제를 원천 봉쇄한다.
- `@Async`: 메일 발송이라는 무거운 작업을 별도의 스레드에서 실행하여, API의 응답 속도에 영향을 주지 않도록 최적화한다.

```java
@Slf4j
@Component
@RequiredArgsConstructor
public class SubscribeEventListener {
    private final MailSender mailSender;
    private final SubscribeWelcomeView welcomeView;

    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void sendWelcomeMail(SubscribeCreatedEvent event) {
        String subject = "앞으로 면접 질문을 보내드릴게요.";
        String text = welcomeView.render(new HashMap<>());
        MailMessage mailMessage = new MailMessage(event.email(), subject, text, welcomeView.getType());
        mailSender.sendMail(mailMessage);
    }
}

```

---

</br>

### 3. 리팩토링이 가져온 아키텍처의 변화

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class SubscribeService {

    private final SubscribeRepository subscribeRepository;
    private final VerifySubscribeService verifySubscribeService;
    private final ApplicationEventPublisher eventPublisher;

    @Transactional
    public void subscribe(SubscribeRequest request) {
        log.info("이메일 구독 요청, 이메일 = {}", request.email());
        trySubscribe(request);
        eventPublisher.publishEvent(new SubscribeCreatedEvent(request.email()));
        log.info("이메일 구독 성공, 이메일 = {}", request.email());
    }
```

이번 리팩토링을 통해 얻은 이점은 단순히 정합성 확보에 그치지 않고, 시스템 아키텍처를 한 단계 변화시키는 계기가 되었다.

- **완벽한 데이터 정합성 보장:** 롤백 시에는 이벤트 리스너가 절대 동작하지 않으므로, 시스템의 상태와 사용자 경험이 완벽하게 일치하게 된다.
- **느슨한 결합과 단일 책임 원칙 준수:** 서비스는 '구독이 생성되었다'는 비즈니스적 사실만 알리고, 메일을 보낼지 말지는 리스너가 결정한다. 계층 간 물리적 의존성이 제거되어 코드의 가독성과 유지보수성이 향상되었다.
- **유연한 확장성 확보:** 만약 "구독 성공 시 통계 서버에 데이터를 전송하라"는 새로운 요구사항이 생긴다면, 기존 코드를 단 한 줄도 수정할 필요 없이 새로운 이벤트 리스너를 하나 더 추가하기만 하면 된다.

---

</br>

### 4. **리팩토링을 마치며: 개인적인 회고**

이번 리팩토링을 통해 몇 가지 중요한 교훈을 얻었다.

첫째, **트랜잭션과 비동기 처리가 함께 사용될 때는 그 실행 시점을 더욱 주의 깊게 살펴봐야 한다**는 점이다. 단순히 비동기로 분리하여 성능을 개선하는 것을 넘어, 두 작업의 생명주기가 비즈니스 흐름에 맞게 동기화되는지 반드시 검토해야 한다는 것을 깨달았다.

둘째, **기술적 관점과 비즈니스 관점의 차이를 인지하는 것이 중요하다.** "비동기로 처리해서 빠르다"는 기술적 장점이 "구독 실패했는데 메일이 온다"는 비즈니스적 결함으로 이어질 수 있다는 것을 직접 확인했다. 결국 좋은 설계는 두 관점 모두를 만족시켜야 한다.

마지막으로, `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`는 이번에 처음 사용해 봤지만, 트랜잭션의 성공이 보장된 후에만 사이드 이펙트를 발생시켜야 하는 여러 상황에서 매우 유용하게 쓰일 것 같다.
