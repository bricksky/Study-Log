## 1. 배경

프로젝트 [매일메일]의 구독 로직을 구현하던 중, `Subscribe` 엔티티 생성자에서 의도를 파악하기 힘든 코드를 발견했습니다.
> 🔗 **관련 PR**: [카테고리별 초기 문제 번호 관리 방식을 개선한다](https://github.com/maeil-mail/maeil-mail-be/pull/295)

</br>
</br>

## 2. 문제 상황: "도대체 15가 뭔데?"

코드를 읽는 도중 다음과 같은 로직을 마주쳤습니다.

```java
// [Before] Subscribe.java
public Subscribe(String email, QuestionCategory category, SubscribeFrequency frequency) {
    // ...
    if (category == QuestionCategory.BACKEND) {
        this.nextQuestionSequence = 15L; // 🚨 Magic Number 발견
    } else {
        this.nextQuestionSequence = 0L;
    }
    // ...

```

### 2.1 무엇이 문제인가?

1. **가독성 저하** 
    1. `15L`이라는 숫자만 봐서는 이것이 "백엔드 질문의 시작 인덱스"인지, "최대 질문 개수"인지, "타임아웃 시간"인지 알 길이 없습니다. 문맥을 다 읽어야만 이해할 수 있습니다.
2. **낮은 응집도** 
    1. '백엔드는 15번부터 시작한다'라는 지식은 사실 `QuestionCategory`가 알고 있어야 할 정보입니다. 
    그런데 이 정보가 뜬금없이 `Subscribe` 클래스에 하드코딩 되어 있습니다.
3. **유지보수 어려움** 
    1. 만약 `DEVOPS`라는 카테고리가 추가되고, 30번부터 시작해야 한다면? `Subscribe` 클래스에 
    `else if`를 추가해야 합니다. 카테고리가 늘어날수록 `Subscribe` 코드가 지저분해집니다.

</br>
</br>


## 3. 해결 과정: Enum에 데이터와 책임 부여하기

이 문제를 해결하기 위해 "상태(Data)를 가지는 Enum"으로 리팩터링을 진행했습니다.


### 3.1 Enum이 스스로 정보를 갖도록 수정

단순히 상수 이름만 나열하던 `QuestionCategory`에 `initialSequence` 필드를 추가했습니다. 
이제 각 카테고리는 자신의 시작 위치를 스스로 기억합니다.

```java
@Getter
public enum QuestionCategory {
    // Enum 상수가 자신의 속성(시작 번호)을 직접 관리함
    FRONTEND("FE", 0L),
    BACKEND("BE", 15L);

    private final String description;
    private final Long initialSequence; // 핵심: 시작 번호를 필드로 가짐

    QuestionCategory(String description, Long initialSequence) {
        this.description = description;
        this.initialSequence = initialSequence;
    }
}
```

### 3.2 비즈니스 로직 단순화

이제 `Subscribe` 클래스는 복잡한 `if-else` 문으로 숫자를 판단할 필요가 없습니다. 
단순히 카테고리에게 **"네 시작 번호가 몇 번이야?"** 라고 물어보면 됩니다.

```java
// [After] Subscribe.java
public Subscribe(String email, QuestionCategory category, SubscribeFrequency frequency) {
    this.email = email;
    this.category = category;
    
    // ✅ 매직 넘버 제거 & 객체에게 메시지를 던짐
    this.nextQuestionSequence = category.getInitialSequence(); 
    
    this.token = UUID.randomUUID().toString();
    this.frequency = frequency;
    this.deletedAt = null;
}
```

</br>
</br>

## 4. 핵심 원칙 및 배운 점

### 4.1 매직 넘버 제거

의미 불명확한 숫자(`15L`)를 `initialSequence`라는 명확한 이름의 변수로 대체했습니다. 
이제 코드를 처음 보는 사람도 "아, 이건 초기 시퀀스 값이구나"라고 즉시 이해할 수 있습니다.


### 4.2 묻지 말고 시켜라

기존 코드는 `Subscribe`가 `Category`의 상태를 확인하고 직접 값을 결정했습니다.

- *Before:* "너 백엔드야? 그럼 15번 가져."
- *After:* "너의 시작 번호를 내놔."

객체의 내부 상태를 바깥에서 판단하지 않고, 객체 스스로가 판단하거나 값을 제공하도록 하여 **캡슐화**를 강화했습니다.


### 4.3 변경의 국소화

나중에 기획이 변경되어 "백엔드 질문을 15번이 아니라 100번부터 시작하자"라고 한다면?

이제는 Subscribe 클래스를 전혀 건드릴 필요 없이, QuestionCategory Enum의 숫자 하나만 바꾸면 됩니다. 관심사의 분리가 잘 이루어졌다는 증거입니다.

</br>
</br>

## 5. 결론

작은 숫자 하나를 옮겼을 뿐이지만, 코드는 훨씬 더 **객체지향적**이고 **유연**해졌습니다. 
"돌아가기만 하는 코드"에서 "읽기 좋고 관리하기 좋은 코드"로 나아가는 첫걸음을 떼었습니다.


</br>

## + 코드리뷰

### 5-1. "잠깐, 이것도 하드코딩 아닌가요?"

Enum으로 깔끔하게 정리하고 뿌듯해하던 찰나, 시니어 개발자분의 날카로운 코드 리뷰가 달렸습니다.

> QuestionCategory enum에 초기 질문지 순서를 캡슐화 하셨군요!
> 
> 
> 개인적인 생각으로는 프론트엔드, 백엔드 카테고리의 초기 질문지 순서를 직접 가지는 것이 실제 DB 데이터에 변경이 생겼을 때, 정합성이 맞지 않을 수 있겠다는 생각이 들어요.
> 
> 어떻게 개선할 수 있을지 같이 얘기해보면 재밌겠네요 답변 기다리겠습니다! 👍 .cc[**@le2sky**](https://github.com/le2sky)
> 

생각해보니 15L을 Subscribe 클래스에서 QuestionCategory로 옮겼을 뿐, "코드가 데이터를 고정적으로 가지고 있다"는 본질적인 문제는 해결되지 않았던 것입니다.

만약 운영 중에 DB에서 질문을 10개 지워버린다면? 코드는 여전히 "15번부터 시작해!"라고 외칠 것이고, 사용자는 존재하지 않는 질문을 요청하게 되어 에러가 발생할 것입니다.

</br>

### 5-2. 비즈니스 맥락의 발견: "왜 하필 15번이었을까?"

이어서 다른 팀원분의 코드리뷰를 통해, `15`라는 숫자에 담긴 진짜 비즈니스 의도를 알게 되었습니다.

> 저는 해당 변경 사항을 긍정적으로 생각하고 있어요. 👍👍
> 
> 
> > 개인적인 생각으로는 프론트엔드, 백엔드 카테고리의 초기 질문지 순서를 직접 가지는 것이 실제 DB 데이터에 변경이 생겼을 때, 정합성이 맞지 않을 수 있겠다는 생각이 들어요.
> > 
> 
> > Enum에 값을 두는 대신 서비스단에서 DB를 조회해 동적으로 값을 받아오는 방식은 어떨까 생각이 들었습니다.
> > 
> 
> DB에 카테고리 별 질문 시작점을 따로 저장한다는 것으로 이해했는데 맞을까요?
> 
> 만약 그렇다면, 15라는 값이 식별자를 의미하는 것이 아니라 순서를 의미하기 때문에 15번째 질문지가 저희가 의도했던 질문지가 아니게 될 경우에 문제가 발생할 것 같아요.
> 
> 백엔드 질문지가 15번부터 시작했던 맥락을 공유드리자면, 서비스 초기에 테스트용 질문지(퀄리티가 낮음)를 넣어놨었는데요. 사용자가 생기면서, 새로운 사용자는 퀄리티가 높은 질문지부터 전달해야겠다고 판단했었습니다. 그래서, 백엔드 시퀀스를 점프시키는 결정을 내렸었어요.
> 
> 최근 백엔드 질문지 피드백 중에 초반에 JPA 관련 질문지가 연속으로 많이 온다는 피드백이 있었어요.
> 
> 만약, 연속된 JPA 질문의 끝이 20번째라고 하면, 20보다 시퀀스가 작은 사용자의 시퀀스를 20으로 점프시킨 이후에 기본 설정값을 20으로 수정하면 된다고 생각하고 있었어요. (기존 사용자는 중복이 없도록)
> 
> 결국 문제의 핵심은 아래와 같다고 저는 생각하는데요.
> 
> 1. 기존 사용자는 중복 질문지를 받지 않아야 하고, (한 질문지는 전체 사이클이 돈 뒤에 그 질문지를 다시 받는다.)
> 2. 질문의 시작점은 변경될 수 있다. ex) 서비스를 구독하고 4일동안 JPA 질문만 온다면 사용자 경험이 안좋을 수 있다. 혹은, 관리자가 질문의 시작점이 마음에 들지 않아서 바꿔야 한다.
> 3. 실제 DB 데이터에 변경이 발생했을 때, 발생하는 이슈들 ex) 백엔드 질문지가 한개 사라져서 15번째가 의도한 질문지가 아니게 되었다.
> 
> 이걸 풀 수 있는 이상적인 설계가 있을까요?
> 
> 제가 과하게 해석했거나, 생각에 부족함이 있다면 피드백 부탁드려요. 🙇🏻‍♂️
> 

단순한 '데이터'가 아니라, '서비스 품질 관리를 위한 운영 정책'이었던 것입니다. 이런 정책값은 코드 수정(배포) 없이 운영자가 원할 때 언제든 바꿀 수 있어야 합니다. 결국 **Enum도 정답이 아니었습니다.**

</br>

### 5-3. 최종 해결: 설정을 DB로 분리하기

이 문제를 완벽하게 해결하기 위해, 시작 번호를 관리하는 별도의 테이블(`CategoryPolicy`)을 만들기로 결정했습니다.

**1. 변경된 설계**

- **Before (Enum)**: 코드를 수정하고 재배포해야 시작 번호 변경 가능.
- **After (DB)**: 운영자가 어드민 페이지에서 숫자만 바꾸면 즉시 반영됨.

**2. 코드 변경**

이제 서비스 로직은 Enum이 아닌, Repository를 통해 현재의 정책을 조회합니다.

```java
// [Final] SubscribeService.java
@Transactional
public void subscribe(SubscribeCommand command) {
    // 1. "지금 백엔드 시작 번호가 몇 번이야?" (DB의 정책 테이블 조회)
    Long startSequence = categoryPolicyRepository.findByCategory(command.getCategory())
            .map(CategoryPolicy::getDefaultStartSequence)
            .orElse(0L); // 설정 없으면 0번부터

    // 2. 조회한 정책값으로 구독 생성
    Subscribe subscribe = new Subscribe(..., startSequence);
    subscribeRepository.save(subscribe);
}
```

이제 질문 데이터가 삭제되거나 순서가 바뀌어도, 혹은 운영자가 "오늘부터 20번부터 시작!"이라고 정책을 바꿔도 **코드는 단 한 줄도 수정할 필요가 없게 되었습니다.**

</br>
</br>

## 6. 결론: 리팩터링은 '제자리 찾기'다

이번 작업을 통해 코드는 세 번의 진화를 거쳤습니다.

1. **Level 1 (Hard Coding)**: `if (backend) 15L`
    - 의도를 알 수 없음.
2. **Level 2 (Enum)**: `QuestionCategory.initialSequence`
    - 의미는 명확해졌으나, 변경에 취약함.
3. **Level 3 (Database Policy)**: `PolicyRepository.find()`
    - 코드와 데이터가 분리되고, 비즈니스 유연성까지 확보함.

처음에는 단순히 "매직 넘버를 없애자"로 시작했지만, 코드 리뷰와 팀원 간의 대화를 통해 **"이 데이터의 진짜 주인은 누구인가?"** 를 고민하게 되었습니다.

결국 좋은 리팩터링이란 단순히 코드를 예쁘게 만드는 것이 아니라, **비즈니스 요구사항과 운영 환경에 맞춰 데이터와 로직의 '진짜 제자리'를 찾아주는 과정**임을 배웠습니다. 

---
