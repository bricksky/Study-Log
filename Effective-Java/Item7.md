
💡자바는 가비지 컬렉터(GC)를 통해 더 이상 참조되지 않는 객체를 자동으로 회수하지만, **개발자가 객체 참조를 잘못 관리하면 GC가 객체를 회수하지 못해 메모리 누수가 발생**할 수 있다. 메모리 누수의 주요 원인과 이를 방지하기 위한 방법을 알아보자.



</br>

## 1. **메모리 누수의 주요 원인**

메모리 누수는 **다 쓴 객체가 더 이상 필요 없음에도 참조가 유지**되어 GC가 이를 회수하지 못하는 상황에서 발생한다. 이로 인해 메모리 사용량이 증가하고, 성능 저하나 `OutOfMemoryError`가 발생할 수 있다. 

주요 원인은 다음과 같다

- **스택(Stack) 구현에서의 문제**: 객체를 스택에서 제거하지 않으면 더 이상 사용하지 않는 객체가 참조되어 메모리 누수가 발생.
- **캐시(Cache)**: 캐시에 저장된 객체가 더 이상 필요 없어도 제거되지 않으면 메모리 누수가 발생.
- **리스너(Listener)나 콜백(Callback)**: 등록된 리스너나 콜백이 해제되지 않으면 객체가 계속 참조되어 GC의 대상이 되지 않음.

</br>

## 2. **예제 1: 스택에서의 메모리 누수**

스택 구현에서 객체 참조를 적절히 해제하지 않으면 메모리 누수가 발생한다. 아래는 책에 나오는 스택 코드와 문제점을 설명한다.

### 2-1) 잘못된 스택 구현 (메모리 누수 발생)

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size]; // 문제 발생 지점
    }

    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}

```

**문제점**:

- `pop()` 메서드에서 객체를 스택에서 제거할 때, `elements[size]`의 참조를 `null`로 설정하지 않음.
- 따라서 `size`가 감소하더라도 배열 `elements`의 해당 인덱스는 여전히 객체를 참조.
- GC는 `elements` 배열이 참조하는 객체를 회수하지 못해 **메모리 누수** 발생.
- 예: 스택에 객체 A, B, C를 `push`한 뒤, `pop`을 호출하면 `size`는 감소하지만, `elements[size]`는 여전히 객체 C를 참조. 객체 C는 더 이상 필요 없지만 GC가 회수하지 못함.

**주의사항**:

- 메모리 누수는 주로 클래스 내부의 자료구조(예: 배열, 컬렉션)에서 발생하므로, 이러한 구조를 관리할 때 주의해야 한다.

### 2-2) 수정된 스택 구현 (메모리 누수 방지)

```java
public Object pop() {
    if (size == 0)
        throw new EmptyStackException();
    Object result = elements[--size];
    elements[size] = null; // 다 쓴 참조 해제
    return result;
}

```

**개선점**:

- `pop()` 메서드에서 객체를 반환하기 전에 `elements[size]`를 `null`로 설정.
- 이를 통해 GC가 더 이상 필요 없는 객체를 회수할 수 있게 함.
- 결과적으로 메모리 누수가 방지됨.

**주의사항**:

- 모든 참조를 무조건 `null`로 설정할 필요는 없다. 예를 들어, 지역 변수는 메서드 종료 시 자동으로 스코프를 벗어나므로 `null` 설정이 불필요하다. 불필요한 `null` 설정은 코드 가독성을 떨어뜨릴 수 있다.

</br>

## 3. **예제 2: 캐시에서의 메모리 누수**

캐시는 객체를 저장하고 재사용하는 경우가 많아 메모리 누수의 주요 원인이 된다. 예를 들어, `HashMap`을 캐시로 사용할 때, 더 이상 필요 없는 키-값 쌍을 제거하지 않으면 메모리 누수가 발생한다.

**해결 방법**:

- **WeakHashMap 사용**: `WeakHashMap`은 키가 더 이상 강하게 참조되지 않을 때 해당 엔트리를 자동으로 제거. 예를 들어:
키가 GC의 대상이 되면 해당 엔트리도 제거되어 메모리 누수 방지.
    
    ```java
    WeakHashMap<Key, Value> cache = new WeakHashMap<>();
    
    ```
    
- **만료 정책 설정**: 캐시 항목에 만료 시간(Time-to-Live, TTL)을 설정하거나, `LinkedHashMap`의 `removeEldestEntry`를 오버라이드하여 오래된 항목 제거.
- **백그라운드 스레드**: 주기적으로 캐시를 정리하는 스레드를 실행.

**주의사항**:

- 캐시 내부의 자료구조를 관리할 때, 더 이상 필요 없는 항목이 참조되지 않도록 주의해야 한다. 불필요한 `null` 설정은 피하고, `WeakHashMap`과 같은 도구를 적절히 활용하자.

</br>

## 4. **예제 3: 리스너와 콜백**

이벤트 리스너나 콜백을 등록한 후 해제하지 않으면 메모리 누수가 발생할 수 있다. 예를 들어, GUI 프레임워크에서 리스너를 등록한 객체가 더 이상 필요 없어도 리스너 목록에 남아 있으면 GC가 회수하지 못한다.

**해결 방법**:

- **명시적으로 리스너 제거**: 객체가 더 이상 필요 없을 때 `removeListener`와 같은 메서드를 호출.
- **약한 참조(Weak Reference) 사용**: `WeakReference`를 사용하여 리스너를 등록하면, 참조가 강하지 않으므로 GC가 객체를 회수할 수 있음.

**주의사항**:

- 리스너나 콜백을 관리할 때, 등록된 객체가 자료구조(예: 리스너 목록)에 남아 있지 않도록 주의해야 한다. 불필요한 `null` 설정 대신, 명시적 제거 메서드 호출을 우선 고려하자.

</br>


## 5. **메모리 누수 방지를 위한 일반적인 방법**

- **다 쓴 참조를 null로 설정**: GC가 객체를 회수할 수 있도록 참조를 해제.
- **자료구조 관리 주의**: 스택, 캐시, 리스너 등에서 더 이상 필요 없는 참조를 제거.
- **약한 참조 활용**: `WeakHashMap`이나 `WeakReference`를 사용해 GC가 객체를 회수하도록 지원.
- **메모리 누수 디버깅**: 메모리 누수가 의심되면 힙 덤프(heap dump)를 분석하거나 프로파일러 도구(예: VisualVM, JProfiler)를 사용.

**주의사항**

- 메모리 누수는 주로 클래스 내부의 자료구조에서 발생하므로, 자료구조 관리에 주의해야 한다. 모든 참조를 무조건 `null`로 설정하는 것은 코드 가독성을 해칠 수 있으므로, 필요한 경우에만 사용하자.

</br>


## 6. **정리**

아이템 7은 자바 개발자가 **메모리 관리에 대한 책임**을 강조한다. 가비지 컬렉터가 모든 메모리 문제를 해결해주지 않으며, 개발자가 객체 참조를 적절히 관리해야 메모리 누수를 방지할 수 있다. 특히, **스택, 캐시, 리스너**와 같은 경우에 주의하며, 약한 참조나 명시적 제거를 통해 GC가 객체를 회수할 수 있도록 해야 한다.
